{
  "title": "Bjarne Stroustrup: C++ | Lex Fridman Podcast #48",
  "id": "uTxRF5ag27A",
  "transcript": "WEBVTT\n\n00:00.000 --> 00:03.120\n The following is a conversation with Bjarne Stroustrup.\n\n00:03.120 --> 00:09.200\n He is the creator of C++, a programming language that, after 40 years, is still one of the most\n\n00:09.200 --> 00:16.240\n popular and powerful languages in the world. Its focus on fast, stable, robust code underlies many\n\n00:16.240 --> 00:21.360\n of the biggest systems in the world that we have come to rely on as a society. If you're watching\n\n00:21.360 --> 00:27.280\n this on YouTube, for example, many of the critical back end components of YouTube are written in C++.\n\n00:27.280 --> 00:34.320\n The same goes for Google, Facebook, Amazon, Twitter, most Microsoft applications, Adobe applications,\n\n00:34.320 --> 00:41.440\n most database systems, and most physical systems that operate in the real world, like cars, robots,\n\n00:41.440 --> 00:45.680\n rockets that launch us into space and one day will land us on Mars.\n\n00:46.480 --> 00:53.200\n C++ also happens to be the language that I use more than any other in my life. I've written\n\n00:53.200 --> 00:59.520\n several hundred thousand lines of C++ source code. Of course, lines of source code don't mean much,\n\n00:59.520 --> 01:03.600\n but they do give hints of my personal journey through the world of software.\n\n01:04.320 --> 01:08.320\n I've enjoyed watching the development of C++ as a programming language,\n\n01:08.320 --> 01:15.360\n leading up to the big update in the standard in 2011 and those that followed in 14, 17,\n\n01:15.360 --> 01:20.320\n and toward the new C++20 standard hopefully coming out next year.\n\n01:20.320 --> 01:23.920\n TITLE This is the Artificial Intelligence podcast.\n\n01:23.920 --> 01:29.280\n If you enjoy it, subscribe on YouTube, give it five stars on iTunes, support it on Patreon,\n\n01:29.280 --> 01:34.960\n or simply connect with me on Twitter at Lex Friedman, spelled F R I D M A N.\n\n01:34.960 --> 01:38.880\n And now, here's my conversation with Bj\u00f6rn Stroustrup.\n\n01:40.240 --> 01:44.000\n What was the first program you've ever written? Do you remember?\n\n01:44.000 --> 01:52.640\n BJ\u00d6RN It was my second year in university, first year of computer science, and it was an Alco 60.\n\n01:53.520 --> 02:01.760\n I calculated the shape of a super ellipse and then connected points on the perimeter,\n\n02:02.400 --> 02:10.400\n creating star patterns. It was with a wet ink on a paper printer.\n\n02:10.400 --> 02:13.200\n TITLE And that was in college, university?\n\n02:13.200 --> 02:17.120\n BJ\u00d6RN Yeah, yeah. I learned to program the second year in university.\n\n02:17.120 --> 02:20.640\n TITLE And what was the first programming language,\n\n02:21.360 --> 02:24.960\n if I may ask it this way, that you fell in love with?\n\n02:24.960 --> 02:32.000\n BJ\u00d6RN I think Alco 60. And after that, I remember\n\n02:34.960 --> 02:41.200\n Snowball. I remember Fortran, didn't fall in love with that. I remember Pascal,\n\n02:41.200 --> 02:48.000\n didn't fall in love with that. It all got in the way of me. And then I discovered Assembler,\n\n02:48.000 --> 02:54.000\n and that was much more fun. And from there, I went to Micro Code.\n\n02:54.000 --> 03:00.640\n TITLE So you were drawn to the, you found the low level stuff beautiful.\n\n03:00.640 --> 03:08.080\n BJ\u00d6RN I went through a lot of languages, and then I spent significant time in Assembler and\n\n03:08.080 --> 03:14.160\n Micro Code. That was sort of the first really profitable things that paid for my masters,\n\n03:14.160 --> 03:18.480\n actually. And then I discovered Simula, which was absolutely great.\n\n03:18.480 --> 03:20.080\n TITLE Simula?\n\n03:20.080 --> 03:24.720\n BJ\u00d6RN Simula was the extension of Alco 60,\n\n03:25.840 --> 03:31.280\n done primarily for simulation. But basically, they invented object oriented programming at\n\n03:31.280 --> 03:40.960\n inheritance and runtime polymorphism while they were doing it. And that was the language that\n\n03:40.960 --> 03:48.320\n taught me that you could have the sort of the problems of a program grow with the size of the\n\n03:48.320 --> 03:55.440\n program rather than with the square of the size of the program. That is, you can actually modularize\n\n03:55.440 --> 04:04.880\n very nicely. And that was a surprise to me. It was also a surprise to me that a stricter type\n\n04:04.880 --> 04:13.440\n system than Pascal's was helpful, whereas Pascal's type system got in my way all the time. So you\n\n04:13.440 --> 04:20.800\n need a strong type system to organize your code well, but it has to be extensible and flexible.\n\n04:20.800 --> 04:25.680\n TITLE Let's get into the details a little bit. If you remember, what kind of type system did\n\n04:25.680 --> 04:30.320\n Pascal have? What type system, typing system did Alco 60 have?\n\n04:30.320 --> 04:37.760\n BJ\u00d6RN Basically, Pascal was sort of the simplest language that Niklaus Wirth could\n\n04:37.760 --> 04:47.200\n define that served the needs of Niklaus Wirth at the time. And it has a sort of a highly moral\n\n04:47.200 --> 04:53.600\n tone to it. That is, if you can say it in Pascal, it's good. And if you can't, it's not so good.\n\n04:54.560 --> 05:05.280\n Whereas Simula allowed you basically to build your own type system. So instead of trying to fit\n\n05:05.280 --> 05:13.920\n yourself into Niklaus Wirth's world, Christen Nygaard's language and Johan Dahl's language\n\n05:13.920 --> 05:22.640\n allowed you to build your own. So it's sort of close to the original idea of you build a domain\n\n05:22.640 --> 05:31.200\n specific language. As a matter of fact, what you build is a set of types and relations among types\n\n05:31.200 --> 05:35.440\n that allows you to express something that's suitable for an application.\n\n05:35.440 --> 05:37.200\n TITLE So when you say types,\n\n05:38.160 --> 05:41.600\n stuff you're saying has echoes of object oriented programming.\n\n05:41.600 --> 05:44.800\n BJ\u00d6RN Yes, they invented it. Every language\n\n05:44.800 --> 05:55.840\n that uses the word class for type is a descendant of Simula, directly or indirectly. Christen Nygaard\n\n05:55.840 --> 06:04.720\n and Ole Johan Dahl were mathematicians and they didn't think in terms of types, but they understood\n\n06:04.720 --> 06:13.840\n sets and classes of elements. And so they called their types classes. And basically in C++,\n\n06:13.840 --> 06:17.040\n as in Simula, classes are user defined type.\n\n06:17.040 --> 06:21.120\n TITLE So can you try the impossible task and give\n\n06:21.120 --> 06:28.240\n a brief history of programming languages from your perspective? So we started with Algol 60,\n\n06:28.240 --> 06:39.440\n Simula, Pascal, but that's just the 60s and 70s. BJ\u00d6RN I can try. The most sort of interesting and\n\n06:39.440 --> 06:47.040\n major improvement of programming languages was Fortran, the first Fortran. Because before that,\n\n06:47.040 --> 06:52.400\n all code was written for a specific machine and each specific machine had a language,\n\n06:52.400 --> 07:02.000\n a simple language or a cross simpler or some extension of that idea. But you're writing for\n\n07:02.000 --> 07:12.880\n a specific machine in the language of that machine. And Bacchus and his team at IBM built a language\n\n07:12.880 --> 07:21.440\n that would allow you to write what you really wanted. That is, you could write it in a language\n\n07:21.440 --> 07:26.880\n that was natural for people. Now, these people happen to be engineers and physicists. So the\n\n07:26.880 --> 07:31.680\n language that came out was somewhat unusual for the rest of the world. But basically they said\n\n07:31.680 --> 07:37.200\n formula translation because they wanted to have the mathematical formulas translated into the\n\n07:37.200 --> 07:47.120\n machine. And as a side effect, they got portability because now they're writing in the terms that the\n\n07:47.120 --> 07:54.000\n humans used and the way humans thought. And then they had a program that translated it into the\n\n07:54.000 --> 08:02.240\n machine's needs. And that was new and that was great. And it's something to remember. We want to\n\n08:02.240 --> 08:07.840\n raise the language to the human level, but we don't want to lose the efficiency.\n\n08:09.200 --> 08:15.200\n And that was the first step towards the human. That was the first step. And of course,\n\n08:15.200 --> 08:20.320\n they were a very particular kind of humans. Business people were different, so they got\n\n08:20.320 --> 08:28.400\n cobalt instead, et cetera, et cetera. And Simula came out. No, let's not go to Simula yet. Let's\n\n08:28.400 --> 08:38.640\n go to Algol. Fortran didn't have, at the time, the notions of not a precise notion of type,\n\n08:38.640 --> 08:48.880\n not a precise notion of scope, not a set of translation phases that was what we have today,\n\n08:49.440 --> 08:55.520\n lexical syntax, semantics. It was sort of a bit of a model in the early days, but\n\n08:56.560 --> 09:01.360\n hey, they've just done the biggest breakthrough in the history of programming, right?\n\n09:01.360 --> 09:06.320\n So you can't criticize them for not having gotten all the technical details right.\n\n09:06.320 --> 09:15.040\n So we got Algol. That was very pretty. And most people in commerce and science considered it\n\n09:15.040 --> 09:20.880\n useless because it was not flexible enough, and it wasn't efficient enough, and et cetera,\n\n09:20.880 --> 09:25.520\n et cetera. But that was a breakthrough from a technical point of view.\n\n09:26.800 --> 09:34.400\n Then Simula came along to make that idea more flexible, and you could define your own types.\n\n09:34.400 --> 09:43.920\n And that's where I got very interested. Christen Nyg\u00e5rd was the main idea man behind Simula.\n\n09:43.920 --> 09:45.200\n That was late 60s.\n\n09:45.200 --> 09:52.000\n This was late 60s. Well, I was a visiting professor in Aarhus, and so I learned object\n\n09:52.000 --> 10:04.400\n oriented programming by sitting around and, well, in theory, discussing with Christen Nyg\u00e5rd. But\n\n10:04.400 --> 10:09.680\n Christen, once you get started and in full flow, it's very hard to get a word in edgeways.\n\n10:09.680 --> 10:10.560\n Where you just listen.\n\n10:10.560 --> 10:14.160\n So it was great. I learned it from there.\n\n10:14.160 --> 10:18.720\n Not to romanticize the notion, but it seems like a big leap to think about\n\n10:18.720 --> 10:23.600\n object oriented programming. It's really a leap of abstraction.\n\n10:24.960 --> 10:25.760\n Yes.\n\n10:25.760 --> 10:34.720\n And was that as big and beautiful of a leap as it seems from now in retrospect,\n\n10:34.720 --> 10:36.960\n or was it an obvious one at the time?\n\n10:38.080 --> 10:44.480\n It was not obvious, and many people have tried to do something like that,\n\n10:44.480 --> 10:48.880\n and most people didn't come up with something as wonderful as Simula.\n\n10:49.920 --> 10:56.720\n Lots of people got their PhDs and made their careers out of forgetting about Simula or never\n\n10:56.720 --> 11:05.040\n knowing it. For me, the key idea was basically I could get my own types. And that's the idea that\n\n11:05.600 --> 11:12.640\n goes further into C++, where I can get better types and more flexible types and more efficient\n\n11:12.640 --> 11:17.760\n types. But it's still the fundamental idea. When I want to write a program, I want to write it with\n\n11:17.760 --> 11:27.200\n my types that is appropriate to my problem and under the constraints that I'm under with hardware,\n\n11:27.200 --> 11:32.000\n software, environment, et cetera. And that's the key idea.\n\n11:32.720 --> 11:39.120\n People picked up on the class hierarchies and the virtual functions and the inheritance,\n\n11:39.120 --> 11:47.360\n and that was only part of it. It was an interesting and major part and still a major\n\n11:47.360 --> 11:55.440\n part and a lot of graphic stuff, but it was not the most fundamental. It was when you wanted to\n\n11:55.440 --> 12:01.680\n relate one type to another. You don't want them all to be independent. The classical example is\n\n12:01.680 --> 12:11.120\n that you don't actually want to write a city simulation with vehicles where you say, well,\n\n12:11.120 --> 12:17.440\n if it's a bicycle, write the code for turning a bicycle to the left. If it's a normal car,\n\n12:17.440 --> 12:23.440\n turn right the normal car way. If it's a fire engine, turn right the fire engine way. You get\n\n12:23.440 --> 12:32.080\n these big case statements and bunches of if statements and such. Instead, you tell the base\n\n12:32.080 --> 12:41.520\n class that that's the vehicle saying, turn left the way you want to. And this is actually a real\n\n12:41.520 --> 12:53.920\n example. They used it to simulate and optimize the emergency services for somewhere in Norway back in\n\n12:53.920 --> 13:01.680\n the 60s. So this was one of the early examples for why you needed inheritance and you needed\n\n13:01.680 --> 13:12.080\n a runtime polymorphism because you wanted to handle this set of vehicles in a manageable way.\n\n13:13.920 --> 13:18.640\n You can't just rewrite your code each time a new kind of vehicle comes along.\n\n13:19.840 --> 13:24.720\n Yeah, that's a beautiful, powerful idea. And of course it stretches through your work\n\n13:24.720 --> 13:33.120\n with C++ as we'll talk about. But I think you've structured it nicely. What other breakthroughs\n\n13:33.120 --> 13:38.480\n came along in the history of programming languages if we were to tell the history in that way?\n\n13:39.440 --> 13:46.000\n Obviously, I'm better at telling the part of the history that is the path I'm on as opposed to all\n\n13:46.000 --> 13:51.440\n the paths. Yeah, you skipped the hippie John McCarthy and Lisp, one of my favorite languages.\n\n13:51.440 --> 13:53.440\n Functional.\n\n13:53.440 --> 13:59.760\n But Lisp is not one of my favorite languages. It's obviously important. It's obviously interesting.\n\n13:59.760 --> 14:05.680\n Lots of people write code in it and then they rewrite it into C or C++ when they want to go\n\n14:05.680 --> 14:15.600\n to production. It's in the world I'm at, which are constrained by performance, reliability,\n\n14:15.600 --> 14:23.520\n issues, deployability, cost of hardware. I don't like things to be too dynamic.\n\n14:24.560 --> 14:32.560\n It is really hard to write a piece of code that's perfectly flexible that you can also deploy on a\n\n14:32.560 --> 14:40.000\n small computer and that you can also put in, say, a telephone switch in Bogota. What's the chance?\n\n14:40.000 --> 14:45.520\n If you get an error and you find yourself in the debugger that the telephone switch in Bogota on\n\n14:45.520 --> 14:53.600\n late Sunday night has a programmer around, their chance is zero. A lot of the things I think most\n\n14:53.600 --> 15:07.120\n about can't afford that flexibility. I'm quite aware that maybe 70%, 80% of all code are not\n\n15:07.120 --> 15:13.840\n under the kind of constraints I'm interested in. But somebody has to do the job I'm doing\n\n15:14.640 --> 15:20.000\n because you have to get from these high level flexible languages to the hardware.\n\n15:20.560 --> 15:27.120\n The stuff that lasts for 10, 20, 30 years is robust, operates under very constrained conditions.\n\n15:27.120 --> 15:31.920\n Yes, absolutely. That's right. And it's fascinating and beautiful in its own way.\n\n15:31.920 --> 15:40.880\n C++ is one of my favorite languages, and so is Lisp. So I can embody two for different reasons\n\n15:40.880 --> 15:50.480\n as a programmer. I understand why Lisp is popular, and I can see the beauty of the ideas\n\n15:50.480 --> 16:04.400\n and similarly with Smalltalk. It's just not as relevant in my world. And by the way, I distinguish\n\n16:04.400 --> 16:12.560\n between those and the functional languages where I go to things like ML and Haskell. Different kind\n\n16:12.560 --> 16:19.040\n of languages, they have a different kind of beauty and they're very interesting. And I think\n\n16:19.040 --> 16:27.680\n that's interesting. And I actually try to learn from all the languages I encounter to see what is\n\n16:27.680 --> 16:34.880\n there that would make working on the kind of problems I'm interested in with the kind of\n\n16:34.880 --> 16:42.880\n constraints that I'm interested in, what can actually be done better? Because we can surely\n\n16:42.880 --> 16:50.400\n do better than we do today. You've said that it's good for any professional programmer to know at\n\n16:50.400 --> 16:57.920\n least five languages as speaking about a variety of languages that you've taken inspiration from,\n\n16:57.920 --> 17:06.320\n and you've listed yours as being, at least at the time, C++, obviously, Java, Python, Ruby,\n\n17:06.320 --> 17:13.520\n script. Can you first of all, update that list, modify it? You don't have to be constrained\n\n17:15.200 --> 17:20.320\n to just five, but can you describe what you picked up also from each of these languages?\n\n17:21.680 --> 17:25.840\n How do you see them as inspirations for you when you're working with C++?\n\n17:25.840 --> 17:32.880\n This is a very hard question to answer. So about languages, you should know\n\n17:32.880 --> 17:42.000\n languages. I reckon I knew about 25 or thereabouts when I did C++. It was easier in those days\n\n17:42.000 --> 17:48.640\n because the languages were smaller, and you didn't have to learn a whole programming environment and\n\n17:48.640 --> 17:55.280\n such to do it. You could learn the language quite easily. And it's good to learn so many languages.\n\n17:55.280 --> 18:03.120\n I imagine, just like with natural language for communication, there's different\n\n18:03.120 --> 18:08.160\n paradigms that emerge in all of them, that there's commonalities and so on.\n\n18:08.800 --> 18:12.640\n So I picked five out of a hat. You picked five out of a hat.\n\n18:12.640 --> 18:16.640\n Obviously. The important thing that the number is not one.\n\n18:17.680 --> 18:18.160\n That's right.\n\n18:19.120 --> 18:24.240\n It's like, I don't like, I mean, if you're a monoglot, you are likely to think that your\n\n18:24.240 --> 18:30.080\n own culture is the only one superior to everybody else's. A good learning of a foreign language and\n\n18:30.080 --> 18:36.160\n a foreign culture is important. It helps you think and be a better person. With programming\n\n18:36.160 --> 18:41.680\n languages, you become a better programmer, better designer with the second language.\n\n18:41.680 --> 18:48.640\n Now, once you've got two, the weight of five is not that long. It's the second one that's\n\n18:48.640 --> 18:58.880\n most important. And then when I had to pick five, I sort of thinking what kinds of languages are\n\n18:58.880 --> 19:04.080\n there? Well, there's a really low level stuff. It's good. It's actually good to know machine code.\n\n19:04.960 --> 19:05.920\n Even still?\n\n19:05.920 --> 19:13.200\n Even today. The C++ optimizers write better machine code than I do.\n\n19:13.200 --> 19:20.640\n Yes. But I don't think I could appreciate them if I actually didn't understand machine code and\n\n19:20.640 --> 19:28.160\n machine architecture. At least in my position, I have to understand a bit of it because you mess\n\n19:28.160 --> 19:35.280\n up the cache and you're off in performance by a factor of 100. It shouldn't be that if you are\n\n19:35.280 --> 19:42.640\n interested in either performance or the size of the computer you have to deploy. So I would\n\n19:42.640 --> 19:51.280\n go as a simpler. I used to mention C, but these days going low level is not actually what gives\n\n19:51.280 --> 19:57.840\n you the performance. It is to express your ideas so cleanly that you can think about it and the\n\n19:57.840 --> 20:04.240\n optimizer can understand what you're up to. My favorite way of optimizing these days is to throw\n\n20:04.240 --> 20:13.360\n away out the clever bits and see if it still runs fast. And sometimes it runs faster. So I need the\n\n20:13.360 --> 20:20.960\n abstraction mechanisms or something like C++ to write compact high performance code. There was a\n\n20:20.960 --> 20:27.680\n beautiful keynote by Jason Turner at the CppCon a couple of years ago where he decided he was going\n\n20:27.680 --> 20:40.320\n to program Pong on Motorola 6800, I think it was. And he says, well, this is relevant because it\n\n20:40.320 --> 20:46.400\n looks like a microcontroller. It has specialized hardware. It has not very much memory and it's\n\n20:46.400 --> 20:56.000\n relatively slow. And so he shows in real time how he writes Pong starting with fairly straightforward\n\n20:56.000 --> 21:03.920\n low level stuff, improving his abstractions and what he's doing. He's writing C++ and it translates\n\n21:06.560 --> 21:13.440\n into 86 assembler, which you can do with Clang and you can see it in real time. It's\n\n21:14.640 --> 21:19.360\n the compiler explorer, which you can use on the web. And then he wrote a little program\n\n21:19.360 --> 21:27.840\n that translated 86 assembler into Motorola assembler. And so he types and you can see this\n\n21:27.840 --> 21:33.200\n thing in real time. Wow. You can see it in real time. And even if you can't read the assembly code,\n\n21:33.840 --> 21:38.880\n you can just see it. His code gets better. The code, the assembler gets smaller.\n\n21:39.600 --> 21:45.440\n He increases the abstraction level, uses C++ 11 as it were better.\n\n21:45.440 --> 21:53.120\n This code gets cleaner. It gets easier maintainable. The code shrinks and it keeps shrinking. And\n\n21:55.120 --> 22:02.240\n I could not in any reasonable amount of time write that assembler as good as the compiler\n\n22:02.240 --> 22:09.360\n generated from really quite nice modern C++. And I'll go as far as to say the thing that looked\n\n22:09.360 --> 22:20.960\n like C was significantly uglier and smaller and larger when it became machine code.\n\n22:22.160 --> 22:26.640\n So the abstractions that can be optimized are important.\n\n22:27.280 --> 22:30.880\n I would love to see that kind of visualization in larger code bases.\n\n22:30.880 --> 22:31.920\n Yeah. That might be beautiful.\n\n22:31.920 --> 22:38.000\n But you can't show a larger code base in a one hour talk and have it fit on screen.\n\n22:38.000 --> 22:40.240\n Right. So that's C and C++.\n\n22:40.240 --> 22:47.120\n So my two languages would be machine code and C++. And then I think you can learn a\n\n22:47.120 --> 22:54.160\n lot from the functional languages. So PIC has gloy ML. I don't care which. I think actually\n\n22:54.800 --> 23:03.200\n you learn the same lessons of expressing especially mathematical notions really clearly\n\n23:03.200 --> 23:11.520\n and having a type system that's really strict. And then you should probably have a language for sort\n\n23:11.520 --> 23:19.280\n of quickly churning out something. You could pick JavaScript. You could pick Python. You could pick\n\n23:19.280 --> 23:26.800\n Ruby. What do you make of JavaScript in general? So you're talking in the platonic sense about\n\n23:26.800 --> 23:32.880\n languages, about what they're good at, what their philosophy of design is. But there's also a large\n\n23:32.880 --> 23:38.400\n user base behind each of these languages and they use it in the way sometimes maybe it wasn't\n\n23:38.400 --> 23:43.600\n really designed for. That's right. JavaScript is used way beyond probably what it was designed for.\n\n23:44.240 --> 23:48.880\n Let me say it this way. When you build a tool, you do not know how it's going to be used.\n\n23:49.440 --> 23:55.200\n You try to improve the tool by looking at how it's being used and when people cut their fingers\n\n23:55.200 --> 24:01.360\n off and try and stop that from happening. But really you have no control over how something\n\n24:01.360 --> 24:07.840\n is used. So I'm very happy and proud of some of the things C++ is being used at and some of the\n\n24:07.840 --> 24:15.120\n things I wish people wouldn't do. Bitcoin mining being my favorite example uses as much energy as\n\n24:15.120 --> 24:25.440\n Switzerland and mostly serves criminals. But back to the languages, I actually think that having\n\n24:25.440 --> 24:33.440\n JavaScript run in the browser was an enabling thing for a lot of things. Yes, you could have\n\n24:33.440 --> 24:41.520\n done it better, but people were trying to do it better and they were using more principles,\n\n24:41.520 --> 24:49.280\n language designs, but they just couldn't do it right. And the nonprofessional programmers that\n\n24:49.280 --> 24:58.640\n write lots of that code just couldn't understand them. So it did an amazing job for what it was.\n\n24:58.640 --> 25:04.080\n It's not the prettiest language and I don't think it ever will be the prettiest language, but\n\n25:05.200 --> 25:10.400\n let's not be bigots here. So what was the origin story of C++?\n\n25:10.400 --> 25:18.400\n Yeah, you basically gave a few perspectives of your inspiration of object oriented programming.\n\n25:19.280 --> 25:24.400\n That's you had a connection with C and performance efficiency was an important\n\n25:24.400 --> 25:29.920\n thing you were drawn to. Efficiency and reliability. Reliability. You have to get both.\n\n25:30.720 --> 25:38.640\n What's reliability? I really want my telephone calls to get through and I want the quality\n\n25:38.640 --> 25:46.400\n of what I am talking, coming out at the other end. The other end might be in London or wherever.\n\n25:48.400 --> 25:55.760\n And you don't want the system to be crashing. If you're doing a bank, you mustn't crash. It might\n\n25:55.760 --> 26:02.640\n be your bank account that is in trouble. There's different constraints like in games, it doesn't\n\n26:02.640 --> 26:06.560\n matter too much if there's a crash, nobody dies and nobody gets ruined.\n\n26:06.560 --> 26:14.560\n But I am interested in the combination of performance, partly because of sort of speed\n\n26:14.560 --> 26:22.800\n of things being done, part of being able to do things that is necessary to have reliability\n\n26:24.320 --> 26:32.560\n of larger systems. If you spend all your time interpreting a simple function call,\n\n26:32.560 --> 26:39.280\n a simple function call, you are not going to have enough time to do proper signal processing to get\n\n26:39.280 --> 26:46.000\n the telephone calls to sound right. Either that or you have to have ten times as many computers\n\n26:46.000 --> 26:51.760\n and you can't afford your phone anymore. It's a ridiculous idea in the modern world because\n\n26:51.760 --> 26:58.160\n we have solved all of those problems. I mean, they keep popping up in different ways because\n\n26:58.160 --> 27:03.120\n we tackle bigger and bigger problems. So efficiency remains always an important aspect.\n\n27:03.120 --> 27:08.800\n But you have to think about efficiency, not just as speed, but as an enabler to\n\n27:09.680 --> 27:17.280\n important things. And one of the things it enables is reliability, is dependability.\n\n27:18.720 --> 27:24.800\n When I press the pedal, the brake pedal of a car, it is not actually connected directly\n\n27:24.800 --> 27:30.160\n to anything but a computer. That computer better work.\n\n27:31.680 --> 27:39.520\n Let's talk about reliability just a little bit. So modern cars have ECUs, have millions of lines\n\n27:39.520 --> 27:46.560\n of code today. So this is certainly especially true of autonomous vehicles where some of the\n\n27:46.560 --> 27:50.720\n aspects of the control or driver assistance systems that steer the car, that keep it in the\n\n27:50.720 --> 27:56.800\n lane and so on. So how do you think, you know, I talked to regulators, people in government\n\n27:56.800 --> 28:03.360\n who are very nervous about testing the safety of these systems of software. Ultimately software\n\n28:03.360 --> 28:11.920\n that makes decisions that could lead to fatalities. So how do we test software systems like these?\n\n28:11.920 --> 28:21.120\n First of all, safety, like performance and like security is the system's property.\n\n28:21.840 --> 28:27.680\n People tend to look at one part of a system at a time and saying something like, this is secure.\n\n28:28.800 --> 28:34.480\n That's all right. I don't need to do that. Yeah, that piece of code is secure. I'll buy\n\n28:34.480 --> 28:41.600\n your operator. If you want to have reliability, if you want to have performance, if you want to\n\n28:41.600 --> 28:46.640\n have security, you have to look at the whole system. I did not expect you to say that,\n\n28:46.640 --> 28:52.480\n but that's very true. Yes, I'm dealing with one part of the system and I want my part to be really\n\n28:52.480 --> 29:00.320\n good, but I know it's not the whole system. Furthermore, if making an individual part perfect,\n\n29:00.320 --> 29:05.680\n may actually not be the best way of getting the highest degree of reliability and performance and\n\n29:05.680 --> 29:14.080\n such. There's people that say C++ is not type safe. You can break it. Sure. I can break anything\n\n29:14.080 --> 29:20.800\n that runs on a computer. I may not go through your type system. If I wanted to break into your\n\n29:20.800 --> 29:26.400\n computer, I'll probably try SQL injection. And it's very true. If you think about\n\n29:26.400 --> 29:32.640\n safety or even reliability at the system level, especially when a human being is involved,\n\n29:34.080 --> 29:42.480\n it starts becoming hopeless pretty quickly in terms of proving that something is\n\n29:43.840 --> 29:48.800\n safe to a certain level. Yeah. Because there's so many variables. It's so complex. Well, let's get\n\n29:48.800 --> 29:54.000\n back to something we can talk about and actually talk about it. Yeah.\n\n29:54.000 --> 30:01.680\n Talk about and actually make some progress on. Yes. We can look at C++ programs and we can\n\n30:01.680 --> 30:12.160\n try and make sure they crash this often. The way you do that is largely by simplification.\n\n30:14.640 --> 30:21.440\n The first step is to simplify the code, have less code, have code that are less likely to go wrong.\n\n30:21.440 --> 30:28.960\n It's not by runtime testing everything. It is not by big test frameworks that you are using.\n\n30:28.960 --> 30:35.600\n Yes, we do that also. But the first step is actually to make sure that when you want to\n\n30:35.600 --> 30:43.120\n express something, you can express it directly in code rather than going through endless loops\n\n30:43.120 --> 30:51.360\n and convolutions in your head before it gets down the code. The way you are thinking about\n\n30:51.360 --> 30:59.360\n a problem is not in the code. There is a missing piece that's just in your head. And the code,\n\n30:59.360 --> 31:05.920\n you can see what it does, but it cannot see what you thought about it unless you have expressed\n\n31:05.920 --> 31:13.120\n things directly. When you express things directly, you can maintain it. It's easier to find errors.\n\n31:13.120 --> 31:19.280\n It's easier to make modifications. It's actually easier to test it. And lo and behold, it runs\n\n31:19.280 --> 31:26.720\n faster. And therefore, you can use a smaller number of computers, which means there's less\n\n31:26.720 --> 31:33.360\n hardware that could possibly break. So I think the key here is simplification.\n\n31:34.000 --> 31:40.080\n But it has to be, to use the Einstein quote, as simple as possible and no simpler.\n\n31:40.080 --> 31:40.800\n Not simpler.\n\n31:41.600 --> 31:46.880\n There are other areas with under constraints where you can be simpler than you can be in C++.\n\n31:46.880 --> 31:52.160\n But in the domain I'm dealing with, that's the simplification I'm after.\n\n31:53.360 --> 32:02.560\n So how do you inspire or ensure that the Einstein level of simplification is reached?\n\n32:03.280 --> 32:11.840\n So can you do code review? Can you look at code? If I gave you the code for the Ford F150\n\n32:11.840 --> 32:21.440\n and said, here, is this a mess or is this okay? Is it possible to tell? Is it possible to regulate?\n\n32:23.040 --> 32:31.680\n An experienced developer can look at code and see if it smells. Mixed metaphors deliberately.\n\n32:31.680 --> 32:45.360\n Yes. The point is that it is hard to generate something that is really obviously clean and\n\n32:46.880 --> 32:52.160\n can be appreciated. But you can usually recognize when you haven't reached that point.\n\n32:52.160 --> 33:03.360\n And so I've never looked at the F150 code, so I wouldn't know. But I know what I ought to be\n\n33:03.360 --> 33:12.080\n looking for. I'll be looking for some tricks that correlate with bugs and elsewhere. And I have tried\n\n33:12.080 --> 33:22.480\n to formulate rules for what good code looks like. And the current version of that is called the C++\n\n33:22.480 --> 33:32.240\n core guidelines. One thing people should remember is there's what you can do in a language and what\n\n33:32.240 --> 33:39.600\n you should do. In a language, you have lots of things that is necessary in some context,\n\n33:39.600 --> 33:45.680\n but not in others. There's things that exist just because there's 30 year old code out there and\n\n33:45.680 --> 33:51.200\n you can't get rid of it. But you can't have rules that says when you create it, try and follow these\n\n33:51.200 --> 34:02.480\n rules. This does not create good programs by themselves, but it limits the damage from mistakes.\n\n34:02.480 --> 34:08.960\n It limits the possibilities of mistakes. And basically, we are trying to say, what is it that\n\n34:08.960 --> 34:16.240\n a good programmer does? At the fairly simple level of where you use the language and how you use it.\n\n34:16.240 --> 34:24.640\n Now, I can put all the rules for chiseling in marble. It doesn't mean that somebody who follows\n\n34:24.640 --> 34:32.160\n all of those rules can do a masterpiece by Michelangelo. That is, there's something else\n\n34:32.160 --> 34:40.640\n to write a good program. Just is there something else to create an important work of art? That is,\n\n34:40.640 --> 34:53.920\n there's some kind of inspiration, understanding, gift. But we can approach the sort of technical,\n\n34:53.920 --> 35:02.400\n the craftsmanship level of it. The famous painters, the famous sculptures was among other things,\n\n35:03.440 --> 35:14.320\n superb craftsmen. They could express their ideas using their tools very well. And so these days,\n\n35:14.320 --> 35:20.000\n I think what I'm doing, what a lot of people are doing, we are still trying to figure out how it is\n\n35:20.000 --> 35:29.280\n to use our tools very well. For a really good piece of code, you need a spark of inspiration,\n\n35:29.280 --> 35:36.640\n and you can't, I think, regulate that. You cannot say that I'll take a picture only,\n\n35:37.200 --> 35:45.600\n I'll buy your picture only if you're at least Van Gogh. There are other things you can regulate,\n\n35:45.600 --> 35:55.200\n but not the inspiration. I think that's quite beautifully put. It is true that there is as an\n\n35:55.200 --> 36:04.640\n experienced programmer, when you see code that's inspired, that's like Michelangelo, you know it\n\n36:04.640 --> 36:12.240\n when you see it. And the opposite of that is code that is messy, code that smells, you know,\n\n36:12.240 --> 36:17.760\n when you see it. And I'm not sure you can describe it in words, except vaguely through guidelines and\n\n36:17.760 --> 36:27.040\n so on. Yes, it's easier to recognize ugly than to recognize beauty in code. And for the reason is\n\n36:27.040 --> 36:34.000\n that sometimes beauty comes from something that's innovative and unusual. And you have to sometimes\n\n36:34.000 --> 36:41.040\n think reasonably hard to appreciate that. On the other hand, the messes have things that are\n\n36:41.040 --> 36:50.160\n in common. And you can have static checkers and dynamic checkers that find\n\n36:52.080 --> 37:02.400\n a large number of the most common mistakes. You can catch a lot of sloppiness mechanically. I'm\n\n37:02.400 --> 37:09.920\n a great fan of static analysis in particular, because you can check for not just the language\n\n37:09.920 --> 37:16.880\n rules, but for the usage of language rules. And I think we will see much more static analysis\n\n37:16.880 --> 37:24.400\n in the coming decade. Can you describe what static analysis is? You represent a piece of code\n\n37:25.840 --> 37:33.760\n so that you can write a program that goes over that representation and look for things that are\n\n37:33.760 --> 37:43.600\n are right and not right. So, for instance, you can analyze a program to see if\n\n37:46.000 --> 37:54.240\n resources are leaked. That's one of my favorite problems. It's not actually all that hard and\n\n37:54.240 --> 38:00.320\n modern C++, but you can do it. If you are writing in the C level, you have to have a malloc and a\n\n38:00.320 --> 38:08.880\n free. And they have to match. If you have them in a single function, you can usually do it very\n\n38:08.880 --> 38:16.320\n easily. If there's a malloc here, there should be a free there. On the other hand, in between can be\n\n38:16.320 --> 38:22.000\n showing complete code and then it becomes impossible. If you pass that pointer to the\n\n38:22.000 --> 38:31.600\n memory out of a function and then want to make sure that the free is done somewhere else,\n\n38:31.600 --> 38:38.000\n now it gets really difficult. And so for static analysis, you can run through a program and you\n\n38:38.000 --> 38:47.120\n can try and figure out if there's any leaks. And what you will probably find is that you will find\n\n38:47.120 --> 38:54.240\n some leaks and you'll find quite a few places where your analysis can't be complete. It might\n\n38:54.240 --> 39:02.880\n depend on runtime. It might depend on the cleverness of your analyzer and it might take a\n\n39:02.880 --> 39:11.120\n long time. Some of these programs run for a long time. But if you combine such analysis\n\n39:11.120 --> 39:17.120\n with a set of rules that says how people could use it, you can actually see why the rules are\n\n39:17.120 --> 39:25.040\n violated. And that stops you from getting into the impossible complexities. You don't want to\n\n39:25.040 --> 39:31.040\n solve the halting problem. So static analysis is looking at the code without running the code.\n\n39:31.040 --> 39:38.880\n Yes. And thereby it's almost not a production code, but it's almost like an education tool\n\n39:38.880 --> 39:45.440\n of how the language should be used. It guides you like it at its best, right? It would\n\n39:45.440 --> 39:50.320\n guide you in how you write future code as well. And you learn together.\n\n39:50.320 --> 39:56.400\n Yes. So basically you need a set of rules for how you use the language. Then you need a static\n\n39:56.400 --> 40:05.120\n analysis that catches your mistakes when you violate the rules or when your code ends up\n\n40:05.120 --> 40:09.200\n doing things that it shouldn't, despite the rules, because there is the language rules.\n\n40:09.200 --> 40:16.000\n We can go further. And again, it's back to my idea that I'd much rather find errors before\n\n40:16.000 --> 40:23.280\n I start running the code. If nothing else, once the code runs, if it catches an error at run times,\n\n40:23.280 --> 40:30.160\n I have to have an error handler. And one of the hardest things to write in code is error handling\n\n40:30.160 --> 40:35.840\n code, because you know something went wrong. Do you know really exactly what went wrong?\n\n40:36.640 --> 40:42.960\n Usually not. How can you recover when you don't know what the problem was? You can't be 100% sure\n\n40:42.960 --> 40:52.480\n what the problem was in many, many cases. And this is part of it. So yes, we need good languages,\n\n40:52.480 --> 41:02.240\n we need good type systems, we need rules for how to use them, we need static analysis. And the\n\n41:02.240 --> 41:08.320\n ultimate for static analysis is of course program proof, but that still doesn't scale to the kind\n\n41:08.320 --> 41:15.200\n of systems we deploy. Then we start needing testing and the rest of the stuff.\n\n41:15.200 --> 41:22.960\n So C++ is an object oriented programming language that creates, especially with its newer versions,\n\n41:22.960 --> 41:29.120\n as we'll talk about, higher and higher levels of abstraction. So how do you design?\n\n41:30.400 --> 41:35.040\n Let's even go back to the origin of C++. How do you design something with so much abstraction\n\n41:35.040 --> 41:45.200\n that's still efficient and is still something that you can manage, do static analysis on,\n\n41:45.200 --> 41:50.480\n you can have constraints on, they can be reliable, all those things we've talked about.\n\n41:50.480 --> 41:59.440\n To me, there's a slight tension between high level abstraction and efficiency.\n\n41:59.440 --> 42:04.560\n That's a good question. I could probably have a year's course just trying to answer it.\n\n42:06.080 --> 42:13.200\n Yes, there's a tension between efficiency and abstraction, but you also get the interesting\n\n42:13.200 --> 42:20.800\n situation that you get the best efficiency out of the best abstraction. And my main tool\n\n42:21.600 --> 42:28.320\n for efficiency for performance actually is abstraction. So let's go back to how C++ was\n\n42:28.320 --> 42:34.000\n got there. You said it was object oriented programming language. I actually never said that.\n\n42:35.040 --> 42:42.880\n It's always quoted, but I never did. I said C++ supports object oriented programming and other\n\n42:42.880 --> 42:51.520\n techniques. And that's important because I think that the best solution to most complex,\n\n42:51.520 --> 43:00.880\n interesting problems require ideas and techniques from things that has been called object oriented\n\n43:02.880 --> 43:14.960\n data abstraction, functional, traditional C style code, all of the above. And so when I was designing\n\n43:14.960 --> 43:24.560\n C++, I soon realized I couldn't just add features. If you just add what looks pretty or what people\n\n43:24.560 --> 43:32.080\n ask for or what you think is good, one by one, you're not going to get a coherent whole. What\n\n43:32.080 --> 43:40.560\n you need is a set of guidelines that that guides your decisions. Should this feature be in or should\n\n43:40.560 --> 43:47.840\n this feature be out? How should a feature be modified before it can go in and such?\n\n43:48.640 --> 43:56.080\n And in the book I wrote about that, the design evolution of C++, there's a whole bunch of rules\n\n43:56.080 --> 44:04.400\n like that. Most of them are not language technical. They're things like don't violate static type\n\n44:04.400 --> 44:12.480\n system because I like static type system for the obvious reason that I like things to be reliable\n\n44:12.480 --> 44:21.280\n on reasonable amounts of hardware. But one of these rules is the zero overhead principle.\n\n44:21.280 --> 44:22.000\n The what kind of principle?\n\n44:22.000 --> 44:29.600\n The zero overhead principle. It basically says that if you have an abstraction,\n\n44:29.600 --> 44:36.320\n it should not cost anything compared to write the equivalent code at a lower level.\n\n44:38.960 --> 44:50.000\n So if I have, say, a matrix multiply, it should be written in such a way that you could not drop to\n\n44:50.000 --> 44:54.800\n the C level of abstraction and use arrays and pointers and such and run faster.\n\n44:54.800 --> 45:01.920\n And so people have written such matrix multiplications, and they've actually gotten\n\n45:01.920 --> 45:07.520\n code that ran faster than Fortran because once you had the right abstraction, you can eliminate\n\n45:08.640 --> 45:16.560\n temporaries and you can do loop fusion and other good stuff like that. That's quite hard to do by\n\n45:16.560 --> 45:21.600\n hand and in a lower level language. And there's some really nice examples of that.\n\n45:21.600 --> 45:28.320\n And the key here is that that matrix multiplication, the matrix abstraction,\n\n45:29.120 --> 45:34.000\n allows you to write code that's simple and easy. You can do that in any language.\n\n45:34.000 --> 45:39.840\n But with C++, it has the features so that you can also have this thing run faster than if you hand\n\n45:39.840 --> 45:47.680\n coded it. Now, people have given that lecture many times, I and others, and a very common\n\n45:47.680 --> 45:52.800\n question after the talk where you have demonstrated that you can outperform Fortran for\n\n45:52.800 --> 45:57.680\n dense matrix multiplication, people come up and says, yeah, but that was C++.\n\n45:57.680 --> 46:04.800\n If I rewrote your code in C, how much faster would it run? The answer is much slower.\n\n46:06.080 --> 46:11.920\n This happened the first time actually back in the 80s with a friend of mine called Doug McElroy,\n\n46:11.920 --> 46:22.080\n who demonstrated exactly this effect. And so the principle is you should give programmers the tools\n\n46:22.080 --> 46:28.560\n so that the abstractions can follow the zero void principle. Furthermore, when you put in a language\n\n46:28.560 --> 46:35.680\n feature in C++ or a standard library feature, you try to meet this. It doesn't mean it's absolutely\n\n46:35.680 --> 46:45.040\n optimal, but it means if you hand code it with the usual facilities in the language in C++ in C,\n\n46:45.040 --> 46:52.800\n you should not be able to better it. Usually you can do better if you use embedded assembler for\n\n46:53.360 --> 47:00.000\n machine code for some of the details to utilize part of a computer that the compiler doesn't know\n\n47:00.000 --> 47:06.880\n about. But you should get to that point before you beat to the abstraction. So that's a beautiful\n\n47:06.880 --> 47:14.640\n ideal to reach for. And we meet it quite often. Quite often. So where's the magic of that coming\n\n47:14.640 --> 47:20.560\n from? There's some of it is the compilation process. So the implementation of C++, some of it\n\n47:20.560 --> 47:27.280\n is the design of the feature itself, the guidelines. So I think it's important that you\n\n47:27.280 --> 47:34.880\n think about the guidelines. So I've recently and often talked to Chris Latner, so Clang.\n\n47:36.320 --> 47:44.160\n What, just out of curiosity, is your relationship in general with the different implementations of\n\n47:44.160 --> 47:50.480\n C++ as you think about you and committee and other people in C++, think about the design of\n\n47:50.480 --> 47:58.080\n features or design of previous features. In trying to reach the ideal of zero overhead,\n\n47:59.840 --> 48:05.920\n does the magic come from the design, the guidelines, or from the implementations?\n\n48:06.480 --> 48:13.840\n And not all. You go for programming technique,\n\n48:13.840 --> 48:18.000\n programming language features, and implementation techniques. You need all three.\n\n48:18.000 --> 48:21.840\n And how can you think about all three at the same time?\n\n48:22.640 --> 48:28.160\n It takes some experience, takes some practice, and sometimes you get it wrong. But after a while,\n\n48:28.160 --> 48:37.840\n you sort of get it right. I don't write compilers anymore. But Brian Kernighan pointed out that one\n\n48:37.840 --> 48:48.640\n of the reasons C++ succeeded was some of the craftsmanship I put into the early compilers.\n\n48:49.760 --> 48:54.080\n And of course, I did the language assign. Of course, I wrote a fair amount of code using\n\n48:54.080 --> 49:02.720\n this kind of stuff. And I think most of the successes involve progress in all three areas\n\n49:02.720 --> 49:10.400\n together. A small group of people can do that. Two, three people can work together to do something\n\n49:10.400 --> 49:16.160\n like that. It's ideal if it's one person that has all the skills necessary. But nobody has all the\n\n49:16.160 --> 49:23.840\n skills necessary in all the fields where C++ is used. So if you want to approach my ideal in, say,\n\n49:23.840 --> 49:30.240\n concurrent programming, you need to know about algorithms from current programming. You need to\n\n49:30.240 --> 49:36.960\n know the trigger of lock free programming. You need to know something about compiler techniques.\n\n49:36.960 --> 49:46.720\n And then you have to know some of the application areas where this is, like some forms of graphics\n\n49:46.720 --> 49:57.440\n or some forms of what we call web server kind of stuff. And that's very hard to get into a single\n\n49:57.440 --> 50:06.800\n head. But small groups can do it too. So is there differences in your view, not saying which is\n\n50:06.800 --> 50:13.680\n better or so on, but differences in the different implementations of C++? Why are there several\n\n50:13.680 --> 50:23.680\n sort of maybe naive questions for me? GCC, clang, so on? This is a very reasonable question. When\n\n50:23.680 --> 50:35.520\n I designed C++, most languages had multiple implementations. Because if you run on an IBM,\n\n50:35.520 --> 50:41.440\n if you run on a Sun, if you run on a Motorola, there was just many, many companies and they each\n\n50:41.440 --> 50:47.200\n have their own compilation structure and their own compilers. It was just fairly common that\n\n50:47.200 --> 50:54.720\n there was many of them. And I wrote C Front assuming that other people would write compilers\n\n50:54.720 --> 51:04.320\n with C++ if successful. And furthermore, I wanted to utilize all the backend infrastructures that\n\n51:04.320 --> 51:10.240\n were available. I soon realized that my users were using 25 different linkers. I couldn't write my\n\n51:10.240 --> 51:19.200\n own linker. Yes, I could, but I couldn't write 25 linkers and also get any work done on the language.\n\n51:20.080 --> 51:26.480\n And so it came from a world where there was many linkers, many optimizers, many\n\n51:27.120 --> 51:36.080\n compiler front ends, not to start, but many operating systems. The whole world was not an\n\n51:36.080 --> 51:44.000\n 86 and a Linux box or something, whatever is the standard today. In the old days, they set a VAX.\n\n51:45.040 --> 51:51.520\n So basically, I assumed there would be lots of compilers. It was not a decision that there should\n\n51:51.520 --> 52:00.400\n be many compilers. It was just a fact. That's the way the world is. And yes, many compilers\n\n52:00.400 --> 52:13.600\n emerged. And today, there's at least four front ends, Clang, GCC, Microsoft, and EDG,\n\n52:13.600 --> 52:21.440\n it is design group. They supply a lot of the independent organizations and the embedded\n\n52:21.440 --> 52:29.040\n systems industry. And there's lots and lots of backends. We have to think about how many dozen\n\n52:29.040 --> 52:35.760\n backends there are. Because different machines have different things, especially in the embedded\n\n52:35.760 --> 52:43.920\n world, the machines are very different, the architectures are very different. And so having\n\n52:43.920 --> 52:52.160\n a single implementation was never an option. Now, I also happen to dislike monocultures.\n\n52:53.120 --> 52:54.320\n Monocultures.\n\n52:54.320 --> 53:01.920\n They are dangerous. Because whoever owns the monoculture can go stale. And there's no\n\n53:01.920 --> 53:09.360\n competition. And there's no incentive to innovate. There's a lot of incentive to put barriers in the\n\n53:09.360 --> 53:15.680\n way of change. Because hey, we own the world. And it's a very comfortable world for us. And who are\n\n53:15.680 --> 53:26.400\n you to mess with that? So I really am very happy that there's four front ends for C++. Clang's\n\n53:26.400 --> 53:36.320\n great. But GCC was great. But then it got somewhat stale. Clang came along. And GCC is much better\n\n53:36.320 --> 53:47.920\n now. Microsoft is much better now. So at least a low number of front ends puts a lot of pressure on\n\n53:51.040 --> 53:57.760\n standards compliance and also on performance and error messages and compile time speed,\n\n53:57.760 --> 53:59.360\n all this good stuff that we want.\n\n53:59.360 --> 54:07.520\n Do you think, crazy question, there might come along, do you hope there might come along\n\n54:08.800 --> 54:15.280\n implementation of C++ written, given all its history, written from scratch?\n\n54:16.400 --> 54:18.960\n So written today from scratch?\n\n54:18.960 --> 54:24.880\n Well, Clang and the LLVM is more or less written from scratch.\n\n54:24.880 --> 54:30.960\n But there's been C++ 11, 14, 17, 20. You know, there's been a lot of\n\n54:30.960 --> 54:36.480\n I think sooner or later somebody's going to try again. There has been attempts to write\n\n54:36.480 --> 54:42.400\n new C++ compilers and some of them has been used and some of them has been absorbed into\n\n54:42.400 --> 54:44.000\n others and such. Yeah, it'll happen.\n\n54:45.200 --> 54:52.960\n So what are the key features of C++? And let's use that as a way to sort of talk about\n\n54:52.960 --> 54:59.360\n the evolution of C++, the new features. So at the highest level, what are the features\n\n54:59.360 --> 55:01.920\n that were there in the beginning? What features got added?\n\n55:03.200 --> 55:13.600\n Let's first get a principle or an aim in place. C++ is for people who want to use hardware\n\n55:13.600 --> 55:18.720\n really well and then manage the complexity of doing that through abstraction.\n\n55:18.720 --> 55:27.120\n And so the first facility you have is a way of manipulating the machines at a fairly low\n\n55:27.120 --> 55:36.560\n level. That looks very much like C. It has loops, it has variables, it has pointers like\n\n55:36.560 --> 55:45.040\n machine addresses, it can access memory directly, it can allocate stuff in the absolute minimum\n\n55:45.040 --> 55:52.560\n of space needed on the machine. There's a machine facing part of C++ which is roughly\n\n55:52.560 --> 55:59.120\n equivalent to C. I said C++ could beat C and it can. It doesn't mean I dislike C. If I\n\n55:59.120 --> 56:07.760\n disliked C, I wouldn't have built on it. Furthermore, after Dennis Ritchie, I'm probably the major\n\n56:07.760 --> 56:18.160\n contributor to modern C. I had lunch with Dennis most days for 16 years and we never\n\n56:18.160 --> 56:26.960\n had a harsh word between us. So these C versus C++ fights are for people who don't quite\n\n56:26.960 --> 56:34.800\n understand what's going on. Then the other part is the abstraction. The key is the class.\n\n56:34.800 --> 56:42.480\n There, the key is the class which is a user defined type. My idea for the class is that\n\n56:42.480 --> 56:48.400\n you should be able to build a type that's just like the building types in the way you\n\n56:48.400 --> 56:54.480\n use them, in the way you declare them, in the way you get the memory and you can do\n\n56:54.480 --> 57:03.680\n just as well. So in C++ there's an int as in C. You should be able to build an abstraction,\n\n57:03.680 --> 57:11.360\n a class which we can call capital int that you can use exactly like an integer and run\n\n57:11.360 --> 57:18.080\n just as fast as an integer. There's the idea right there. And of course you probably don't\n\n57:18.080 --> 57:25.600\n want to use the int itself but it has happened. People have wanted integers that were range\n\n57:25.600 --> 57:29.840\n checked so that you couldn't overflow and such, especially for very safety critical\n\n57:29.840 --> 57:36.320\n applications like the fuel injection for a marine diesel engine for the largest ships.\n\n57:37.040 --> 57:43.360\n This is a real example by the way. This has been done. They built themselves an integer\n\n57:43.360 --> 57:49.200\n that was just like integer except that couldn't overflow. If there was an overflow you went\n\n57:49.200 --> 57:56.880\n into the error handling. And then you built more interesting types. You can build a matrix\n\n57:56.880 --> 58:03.600\n which you need to do graphics or you could build a gnome for a video game.\n\n58:04.400 --> 58:07.760\n And all these are classes and they appear just like the built in types.\n\n58:07.760 --> 58:08.240\n Exactly.\n\n58:08.240 --> 58:11.120\n In terms of efficiency and so on. So what else is there?\n\n58:11.120 --> 58:12.320\n And flexibility.\n\n58:12.320 --> 58:20.400\n So I don't know, for people who are not familiar with object oriented programming there's inheritance.\n\n58:20.400 --> 58:27.040\n There's a hierarchy of classes. You can just like you said create a generic vehicle that can turn\n\n58:27.040 --> 58:27.600\n left.\n\n58:27.600 --> 58:40.320\n So what people found was that you don't actually know. How do I say this? A lot of types are\n\n58:40.320 --> 58:52.960\n related. That is the vehicles, all vehicles are related. Bicycles, cars, fire engines, tanks. They\n\n58:52.960 --> 58:57.600\n have some things in common and some things that differ. And you would like to have the common\n\n58:57.600 --> 59:04.160\n things common and having the differences specific. And when you didn't want to know about\n\n59:04.160 --> 59:12.640\n the differences, just turn left. You don't have to worry about it. That's how you get the traditional\n\n59:12.640 --> 59:19.520\n object oriented programming coming out of Simula adopted by Smalltalk and C++ and all the other\n\n59:19.520 --> 59:25.840\n languages. The other kind of obvious similarity between types comes when you have something like\n\n59:25.840 --> 59:35.760\n a vector. Fortran gave us the vector as called array of doubles. But the minute you have a\n\n59:35.760 --> 59:42.720\n vector of doubles, you want a vector of double precision doubles and for short doubles for\n\n59:42.720 --> 59:50.640\n graphics. And why should you not have a vector of integers while you're added or a vector of\n\n59:50.640 --> 1:00:01.040\n vectors and a vector of vectors of chess pieces? Now you have a board, right? So this is you\n\n1:00:01.040 --> 1:00:09.200\n express the commonality as the idea of a vector and the variations come through parameterization.\n\n1:00:10.080 --> 1:00:17.360\n And so here we get the two fundamental ways of abstracting or of having similarities of\n\n1:00:17.360 --> 1:00:23.120\n types in C++. There's the inheritance and there's a parameterization. There's the object oriented\n\n1:00:23.120 --> 1:00:27.920\n programming and there's the generic programming. With the templates for the generic programming.\n\n1:00:27.920 --> 1:00:37.040\n Yep. So you've presented it very nicely, but now you have to make all that happen and make it\n\n1:00:37.040 --> 1:00:43.280\n efficient. So generic programming with templates, there's all kinds of magic going on, especially\n\n1:00:43.280 --> 1:00:50.160\n recently that you can help catch up on. But it feels to me like you can do way more than what\n\n1:00:50.160 --> 1:00:55.760\n you just said with templates. You can start doing this kind of metaprogramming, this kind of...\n\n1:00:55.760 --> 1:01:02.320\n You can do metaprogramming also. I didn't go there in that explanation. We're trying to be\n\n1:01:02.320 --> 1:01:08.160\n very basic, but go back on to the implementation. If you couldn't implement this efficiently,\n\n1:01:08.160 --> 1:01:14.400\n if you couldn't use it so that it became efficient, it has no place in C++ because\n\n1:01:14.400 --> 1:01:22.560\n it will violate the zero overhead principle. So when I had to get object oriented programming\n\n1:01:22.560 --> 1:01:31.360\n inheritance, I took the idea of virtual functions from Simula. Virtual functions is a Simula term,\n\n1:01:31.360 --> 1:01:38.640\n class is a Simula term. If you ever use those words, say thanks to Christen Nygaard and Olli\n\n1:01:38.640 --> 1:01:46.720\n H\u00f8ndahl. And I did the simplest implementation I knew of, which was basically a jump table.\n\n1:01:47.520 --> 1:01:54.080\n So you get the virtual function table, the function goes in, does an indirection through\n\n1:01:54.080 --> 1:01:58.000\n a table and get the right function. That's how you pick the right thing there.\n\n1:01:58.000 --> 1:02:06.000\n And I thought that was trivial. It's close to optimal and it was obvious. It turned out the\n\n1:02:06.000 --> 1:02:12.400\n Simula had a more complicated way of doing it and therefore was slower. And it turns out that most\n\n1:02:12.400 --> 1:02:16.880\n languages have something that's a little bit more complicated, sometimes more flexible,\n\n1:02:16.880 --> 1:02:22.880\n but you pay for it. And one of the strengths of C++ was that you could actually do this object\n\n1:02:22.880 --> 1:02:30.800\n oriented stuff and your overhead compared to ordinary functions, there's no indirection. It's\n\n1:02:30.800 --> 1:02:40.400\n sort of in 5, 10, 25% just the call. It's down there. It's not two. And that means you can\n\n1:02:40.400 --> 1:02:46.960\n afford to use it. Furthermore, in C++, you have the distinction between a virtual function and\n\n1:02:46.960 --> 1:02:53.040\n a nonvirtual function. If you don't want any overhead, if you don't need the indirection that\n\n1:02:53.040 --> 1:03:00.640\n gives you the flexibility in object oriented programming, just don't ask for it. So the idea\n\n1:03:00.640 --> 1:03:06.640\n is that you only use virtual functions if you actually need the flexibility. So it's not zero\n\n1:03:06.640 --> 1:03:11.360\n overhead, but it's zero overhead compared to any other way of achieving the flexibility.\n\n1:03:11.360 --> 1:03:25.040\n Now, auto parameterization. Basically, the compiler looks at the template, say the vector,\n\n1:03:25.040 --> 1:03:34.400\n and it looks at the parameter, and then combines the two and generates a piece of code that is\n\n1:03:34.400 --> 1:03:42.400\n exactly as if you've written a vector of that specific type. So that's the minimal overhead.\n\n1:03:42.400 --> 1:03:47.920\n If you have many template parameters, you can actually combine code that the compiler couldn't\n\n1:03:47.920 --> 1:03:56.080\n usually see at the same time and therefore get code that is faster than if you had handwritten\n\n1:03:56.080 --> 1:04:04.800\n the stuff, unless you are very, very clever. So the thing is, parameterized code, the compiler\n\n1:04:04.800 --> 1:04:12.320\n fills stuff in during the compilation process, not during runtime. That's right. And furthermore,\n\n1:04:12.320 --> 1:04:20.160\n it gives all the information it's gotten, which is the template, the parameter, and the context\n\n1:04:20.160 --> 1:04:30.480\n of use. It combines the three and generates good code. But it can generate, now, it's a little\n\n1:04:30.480 --> 1:04:35.360\n outside of what I'm even comfortable thinking about, but it can generate a lot of code. Yes.\n\n1:04:36.560 --> 1:04:45.440\n And how do you, I remember being both amazed at the power of that idea, and\n\n1:04:45.440 --> 1:04:50.960\n how ugly the debugging looked? Yes. Debugging can be truly horrid.\n\n1:04:51.520 --> 1:04:57.040\n Come back to this, because I have a solution. Anyway, the debugging was ugly.\n\n1:04:58.320 --> 1:05:06.880\n The code generated by C++ has always been ugly, because there's these inherent optimizations.\n\n1:05:06.880 --> 1:05:10.720\n A modern C++ compiler has front end, middle end, and back end.\n\n1:05:10.720 --> 1:05:18.640\n Even C Front, back in 83, had front end and back end optimizations. I actually took the code,\n\n1:05:20.320 --> 1:05:27.680\n generated an internal representation, munched that representation to generate good code.\n\n1:05:27.680 --> 1:05:33.200\n So people say, it's not a compiler, it generates C. The reason it generated C was I wanted to use\n\n1:05:33.200 --> 1:05:38.480\n C's code generator, and I wanted to use C's code generator to generate good code.\n\n1:05:38.480 --> 1:05:43.280\n C was I wanted to use C's code generators that was really good at back end optimizations.\n\n1:05:44.080 --> 1:05:50.320\n But I needed front end optimizations, and therefore, the C I generated was optimized C.\n\n1:05:51.280 --> 1:06:00.560\n The way a really good handcrafted optimizer human could generate it, and it was not meant\n\n1:06:00.560 --> 1:06:06.160\n for humans. It was the output of a program, and it's much worse today. And with templates,\n\n1:06:06.160 --> 1:06:16.960\n it gets much worse still. So it's hard to combine simple debugging with the optimal code,\n\n1:06:16.960 --> 1:06:24.080\n because the idea is to drag in information from different parts of the code to generate good code,\n\n1:06:25.680 --> 1:06:34.240\n machine code. And that's not readable. So what people often do for debugging\n\n1:06:34.240 --> 1:06:42.720\n is they turn the optimizer off. And so you get code that when something in your source code\n\n1:06:42.720 --> 1:06:50.480\n looks like a function call, it is a function call. When the optimizer is turned on, it may disappear,\n\n1:06:50.480 --> 1:06:58.400\n the function call, it may inline. And so one of the things you can do is you can actually get code\n\n1:06:58.400 --> 1:07:05.760\n that is smaller than the function call, because you eliminate the function preamble and return.\n\n1:07:06.320 --> 1:07:11.040\n And there's just the operation there. One of the key things when I did\n\n1:07:13.280 --> 1:07:20.080\n templates was I wanted to make sure that if you have, say, a sort algorithm, and you give it a\n\n1:07:20.080 --> 1:07:30.560\n sorting criteria, if that sorting criteria is simply comparing things with less than,\n\n1:07:31.360 --> 1:07:38.880\n the code generated should be the less than, not an indirect function call to a comparison\n\n1:07:40.560 --> 1:07:47.120\n object, which is what it is in the source code. But we really want down to the single instruction.\n\n1:07:47.120 --> 1:07:54.240\n But anyway, turn off the optimizer, and you can debug. The first level of debugging can be done,\n\n1:07:54.240 --> 1:07:59.360\n and I always do without the optimization on, because then I can see what's going on.\n\n1:07:59.360 --> 1:08:07.840\n And then there's this idea of concepts that puts some, now I've never even,\n\n1:08:09.360 --> 1:08:14.640\n I don't know if it was ever available in any form, but it puts some constraints\n\n1:08:14.640 --> 1:08:17.280\n on the stuff you can parameterize, essentially.\n\n1:08:18.240 --> 1:08:27.440\n Let me try and explain this. So yes, it wasn't there 10 years ago. We have had versions of it\n\n1:08:27.440 --> 1:08:37.120\n that actually work for the last four or five years. It was a design by Gabi Dos Reis, Drew\n\n1:08:37.120 --> 1:08:46.720\n Sutton and me. We were professors and postdocs in Texas at the time. And the implementation by\n\n1:08:46.720 --> 1:08:59.040\n Andrew Sutton has been available for that time. And it is part of C++20. And there's a standard\n\n1:08:59.040 --> 1:09:10.640\n library that uses it. So this is becoming really very real. It's available in Clang and GCC. GCC\n\n1:09:10.640 --> 1:09:17.120\n for a couple of years, and I believe Microsoft is soon going to do it. We expect all of C++20\n\n1:09:17.120 --> 1:09:26.720\n to be available in all the major compilers in 20. But this kind of stuff is available now.\n\n1:09:26.720 --> 1:09:30.720\n I'm just saying that because otherwise people might think I was talking about science fiction.\n\n1:09:31.920 --> 1:09:35.440\n And so what I'm going to say is concrete. You can run it today.\n\n1:09:37.040 --> 1:09:46.240\n And there's production uses of it. So the basic idea is that when you have a generic component,\n\n1:09:47.200 --> 1:09:54.560\n like a sort function, the sort function will require at least two parameters. One is the\n\n1:09:54.560 --> 1:10:03.120\n data structure with a given type and a comparison criteria. And these things are related, but\n\n1:10:03.680 --> 1:10:07.840\n obviously you can't compare things if you don't know what the type of things you compare.\n\n1:10:10.160 --> 1:10:16.880\n And so you want to be able to say, I'm going to sort something and it is to be sortable.\n\n1:10:16.880 --> 1:10:20.960\n What does it mean to be sortable? You look it up in the standard. It has to have a\n\n1:10:20.960 --> 1:10:27.200\n it has to be a sequence with a beginning and an end. There has to be random access to that sequence.\n\n1:10:27.200 --> 1:10:34.800\n And there has to be the element types has to be comparable by default.\n\n1:10:34.800 --> 1:10:37.040\n Which means less than operator can operate on.\n\n1:10:37.040 --> 1:10:37.600\n Yes.\n\n1:10:37.600 --> 1:10:39.120\n Less than logical operator can operate.\n\n1:10:39.120 --> 1:10:45.360\n Basically what concepts are, they're compile time predicates. They're predicates you can ask,\n\n1:10:45.360 --> 1:10:52.800\n are you a sequence? Yes, I have a beginning and end. Are you a random access sequence? Yes,\n\n1:10:52.800 --> 1:11:00.560\n I have a subscripting and plus. Is your element type something that has a less than? Yes,\n\n1:11:00.560 --> 1:11:06.960\n I have a less than it's and so basically that's the system. And so instead of saying,\n\n1:11:06.960 --> 1:11:11.440\n I will take a parameter of any type, it'll say, I'll take something that's sortable.\n\n1:11:11.440 --> 1:11:17.920\n And it's well defined. And so we say, okay, you can sort with less than, I don't want less than,\n\n1:11:17.920 --> 1:11:23.920\n I want greater than or something I invent. So you have two parameters, the sortable thing and the\n\n1:11:24.720 --> 1:11:33.920\n comparison criteria. And the comparison criteria will say, well, I can, you can write it saying it\n\n1:11:33.920 --> 1:11:41.200\n should operate on the element type. And then you can say, well, I can sort with less than,\n\n1:11:41.200 --> 1:11:49.200\n and it has the comparison operations. So that's just simply the fundamental thing. It's compile\n\n1:11:49.200 --> 1:11:56.320\n time predicates. Do you have the properties I need? So it specifies the requirements of the code\n\n1:11:56.320 --> 1:12:05.280\n on the parameters that it gets. It's very similar to types actually. But operating in the space of\n\n1:12:05.280 --> 1:12:15.200\n concepts. Concepts. The word concept was used by Alex Stefanov, who is sort of the father of generic\n\n1:12:15.200 --> 1:12:23.520\n programming in the context of C++. There's other places that use that word, but the way we call\n\n1:12:23.520 --> 1:12:29.040\n it generic programming is Alex's. And he called them concepts because he said they are the sort\n\n1:12:29.040 --> 1:12:34.720\n of the fundamental concepts of an area. So they should be called concepts. And we've had\n\n1:12:34.720 --> 1:12:42.480\n concepts all the time. If you look at the KNR book about C, C has arithmetic types and it has\n\n1:12:45.760 --> 1:12:52.480\n integral types. It says so in the book. And then it lists what they are and they have certain\n\n1:12:52.480 --> 1:12:59.200\n properties. The difference today is that we can actually write a concept that will ask a type,\n\n1:12:59.200 --> 1:13:05.200\n are you an integral type? Do you have the properties necessary to be an integral type?\n\n1:13:05.200 --> 1:13:15.200\n Do you have plus, minus, divide and such? So maybe the story of concepts, because I thought\n\n1:13:15.200 --> 1:13:25.680\n it might be part of C++11. C O X or whatever it was at the time. What was the, why didn't it,\n\n1:13:25.680 --> 1:13:30.560\n what, like what we'll, we'll talk a little bit about this fascinating process of standards,\n\n1:13:30.560 --> 1:13:34.000\n because I think it's really interesting for people. It's interesting for me,\n\n1:13:34.000 --> 1:13:40.000\n but why did it take so long? What shapes did the idea of concepts take?\n\n1:13:41.760 --> 1:13:48.320\n What were the challenges? Back in 87 or thereabouts. 1987?\n\n1:13:49.120 --> 1:13:54.960\n Well, 1987 or thereabouts when I was designing templates, obviously I wanted to express the\n\n1:13:54.960 --> 1:14:03.920\n notion of what is required by a template of its arguments. And so I looked at this and basically\n\n1:14:03.920 --> 1:14:14.000\n for templates, I wanted three properties. I wanted to be very flexible. It had to be able to express\n\n1:14:14.000 --> 1:14:20.480\n things I couldn't imagine because I know I can't imagine everything. And I've been suffering from\n\n1:14:20.480 --> 1:14:27.600\n languages that try to constrain you to only do what the designer thought good. Didn't want to\n\n1:14:27.600 --> 1:14:35.920\n do that. Secondly, it had to run faster, as fast or faster than handwritten code. So basically,\n\n1:14:35.920 --> 1:14:43.520\n if I have a vector of T and I take a vector of char, it should run as fast as you built a vector\n\n1:14:43.520 --> 1:14:51.440\n of char yourself without parameterization. And thirdly, I wanted to be able to express\n\n1:14:52.480 --> 1:15:00.480\n the constraints of the arguments, have proper type checking of the interfaces.\n\n1:15:01.680 --> 1:15:09.360\n And neither I nor anybody else at the time knew how to get all three. And I thought for C++,\n\n1:15:09.360 --> 1:15:17.040\n I must have the two first. Otherwise, it's not C++. And it bothered me for another couple of\n\n1:15:17.040 --> 1:15:23.600\n decades that I couldn't solve the third one. I mean, I was the one that put function argument\n\n1:15:23.600 --> 1:15:29.840\n type checking into C. I know the value of good interfaces. I didn't invent that idea. It's very\n\n1:15:29.840 --> 1:15:37.600\n common, but I did it. And I wanted to do the same for templates, of course, and I couldn't.\n\n1:15:37.600 --> 1:15:47.840\n So it bothered me. Then we tried again, 2002, 2003. Gaby DesRays and I started analyzing the\n\n1:15:47.840 --> 1:15:57.280\n problem, explained possible solutions. It was not a complete design. A group in University of Indiana,\n\n1:15:57.280 --> 1:16:10.240\n an old friend of mine, they started a project at Indiana and we thought we could get\n\n1:16:11.360 --> 1:16:22.000\n a good system of concepts in another two or three years that would have made C++ 11 to C++\n\n1:16:22.000 --> 1:16:33.280\n 06 or 07. Well, it turns out that I think we got a lot of the fundamental ideas wrong. They were\n\n1:16:33.280 --> 1:16:41.920\n too conventional. They didn't quite fit C++ in my opinion. Didn't serve implicit conversions very\n\n1:16:41.920 --> 1:16:51.120\n well. It didn't serve mixed type arithmetic, mixed type computations very well. A lot of\n\n1:16:51.120 --> 1:17:03.200\n stuff came out of the functional community and that community didn't deal with multiple types\n\n1:17:03.200 --> 1:17:12.480\n in the same way as C++ does, had more constraints on what you could express and didn't have the\n\n1:17:12.480 --> 1:17:19.760\n draconian performance requirements. And basically we tried. We tried very hard. We had some\n\n1:17:19.760 --> 1:17:30.560\n successes, but it just in the end wasn't, didn't compile fast enough, was too hard to use and\n\n1:17:31.440 --> 1:17:40.080\n didn't run fast enough unless you had optimizers that was beyond the state of the art. They still\n\n1:17:40.080 --> 1:17:49.120\n are. So we had to do something else. Basically it was the idea that a set of parameters has\n\n1:17:49.120 --> 1:17:55.760\n defined a set of operations and you go through an interaction table just like for virtual functions\n\n1:17:55.760 --> 1:18:03.360\n and then you try to optimize the interaction away to get performance. And we just couldn't\n\n1:18:03.360 --> 1:18:12.720\n do all of that. But get back to the standardization. We are standardizing C++ under ISO rules,\n\n1:18:12.720 --> 1:18:20.160\n which are very open process. People come in, there's no requirements for education or experience.\n\n1:18:20.160 --> 1:18:28.960\n So you started to develop C++ and there's a whole, when was the first standard established? What is\n\n1:18:28.960 --> 1:18:34.960\n that like? The ISO standard, is there a committee that you're referring to? There's a group of\n\n1:18:34.960 --> 1:18:39.280\n people. What was that like? How often do you meet? What's the discussion?\n\n1:18:39.280 --> 1:18:52.720\n I'll try and explain that. So sometime in early 1989, two people, one from IBM, one from HP,\n\n1:18:52.720 --> 1:19:02.080\n turned up in my office and told me I would like to standardize C++. This was a new idea to me and\n\n1:19:02.080 --> 1:19:09.760\n when I pointed out that it wasn't finished yet and it wasn't ready for formal standardization\n\n1:19:09.760 --> 1:19:14.480\n and such. And they say, no, Bjarne, you haven't gotten it. You really want to do this.\n\n1:19:16.400 --> 1:19:23.760\n Our organizations depend on C++. We cannot depend on something that's owned by another\n\n1:19:23.760 --> 1:19:31.040\n corporation that might be a competitor. Of course we could rely on you, but you might get run over\n\n1:19:31.040 --> 1:19:41.840\n by a boss. We really need to get this out in the open. It has to be standardized under formal rules\n\n1:19:41.840 --> 1:19:51.120\n and we are going to standardize it under ISO rules and you really want to be part of it because\n\n1:19:51.120 --> 1:20:00.800\n basically otherwise we'll do it ourselves. And we know you can do it better. So through a combination\n\n1:20:00.800 --> 1:20:14.400\n of arm twisting and flattery, it got started. So in late 89, there was a meeting in DC at the,\n\n1:20:15.600 --> 1:20:20.640\n actually no, it was not ISO then, it was ANSI, the American National Standard doing.\n\n1:20:23.200 --> 1:20:30.480\n We met there. We were lectured on the rules of how to do an ANSI standard. There was about 25 of us\n\n1:20:30.480 --> 1:20:38.800\n there, which apparently was a new record for that kind of meeting. And some of the old C guys that\n\n1:20:38.800 --> 1:20:45.440\n has been standardized in C was there. So we got some expertise in. So the way this works is that\n\n1:20:45.440 --> 1:20:52.720\n it's an open process. Anybody can sign up if they pay the minimal fee, which is about a thousand\n\n1:20:52.720 --> 1:21:01.040\n dollars, less than a little bit more now. And I think it's $1,280. It's not going to kill you.\n\n1:21:01.680 --> 1:21:10.880\n And we have three meetings a year. This is fairly standard. We tried two meetings a year for a\n\n1:21:10.880 --> 1:21:20.160\n couple of years that didn't work too well. So three one week meetings a year and you meet\n\n1:21:20.160 --> 1:21:28.320\n and you have technical discussions, and then you bring proposals forward for votes. The votes are\n\n1:21:28.320 --> 1:21:39.040\n done one person per, one vote per organization. So you can't have say IBM come in with 10 people\n\n1:21:39.040 --> 1:21:44.160\n and dominate things that's not allowed. And these are organizations that extensively UC\n\n1:21:44.160 --> 1:21:52.640\n plus plus. Yes. Or individuals or individuals. I mean, it's a bunch of people in the room\n\n1:21:53.280 --> 1:22:00.400\n deciding the design of a language based on which a lot of the world's systems run.\n\n1:22:00.400 --> 1:22:05.440\n Right. Well, I think most people would agree it's better than if I decided it\n\n1:22:06.240 --> 1:22:13.200\n or better than if a single organization like AG&T decides it. I don't know if everyone agrees to\n\n1:22:13.200 --> 1:22:22.560\n that, by the way. Bureaucracies have their critics too. Yes. Look, standardization is not pleasant.\n\n1:22:23.360 --> 1:22:31.200\n It's horrifying. It's like democracy. Exactly. As Churchill says, democracy is the worst way,\n\n1:22:31.200 --> 1:22:36.480\n except for the others. Right. And it's, I would say the same with formal standardization.\n\n1:22:36.480 --> 1:22:44.400\n But anyway, so we meet and we have these votes and that determines what the standard is.\n\n1:22:45.040 --> 1:22:53.280\n A couple of years later, we extended this so it became worldwide. We have standard organizations\n\n1:22:53.280 --> 1:23:07.760\n that are active in currently 15 to 20 countries and another 15 to 20 are sort of looking and voting\n\n1:23:08.800 --> 1:23:15.680\n based on the rest of the work on it. And we meet three times a year. Next week I'll be in Cologne,\n\n1:23:15.680 --> 1:23:25.440\n Germany, spending a week doing standardization and we'll vote out the committee draft of C++20,\n\n1:23:25.440 --> 1:23:34.000\n which goes to the national standards committees for comments and requests for changes and\n\n1:23:34.000 --> 1:23:39.600\n improvements. Then we do that and there's a second set of votes where hopefully everybody\n\n1:23:39.600 --> 1:23:47.040\n votes in favor. This has happened several times. The first time we finished, we started in the\n\n1:23:47.040 --> 1:23:55.760\n first technical meeting was in 1990. The last was in 98. We voted it out. That was the standard\n\n1:23:55.760 --> 1:24:04.000\n that people used until 11 or a little bit past 11. And it was an international standard. All the\n\n1:24:04.000 --> 1:24:13.440\n countries voted in favor. It took longer with 11. I'll mention why, but all the nations voted in\n\n1:24:13.440 --> 1:24:23.440\n favor. And we work on the basis of consensus. That is, we do not want something that passes 6040\n\n1:24:24.400 --> 1:24:30.240\n because then we're going to get dialects and opponents and people complain too much. They\n\n1:24:30.240 --> 1:24:37.280\n all complain too much, but basically it has no real effect. The standards has been obeyed. They\n\n1:24:37.280 --> 1:24:44.880\n have been working to make it easier to use many compilers, many computers and all of that kind of\n\n1:24:44.880 --> 1:24:54.080\n stuff. It was traditional with ISO standards to take 10 years. We did the first one in eight,\n\n1:24:54.080 --> 1:25:00.400\n brilliant. And we thought we were going to do the next one in six because now we are good at it.\n\n1:25:00.400 --> 1:25:10.720\n Right. It took 13. Yeah. It was named OX. It was named OX. Hoping that you would at least get it\n\n1:25:10.720 --> 1:25:15.760\n within the single, within the odds, the single digits. I thought we would get, I thought we'd\n\n1:25:15.760 --> 1:25:21.920\n get six, seven or eight. The confidence of youth. That's right. Well, the point is that this was\n\n1:25:21.920 --> 1:25:28.160\n sort of like a second system effect. That is, we now knew how to do it. And so we're going to do\n\n1:25:28.160 --> 1:25:35.680\n it much better. And we've got more ambitious and it took longer. Furthermore, there is this tendency\n\n1:25:35.680 --> 1:25:45.200\n because it's a 10 year cycle or it doesn't matter. Just before you're about to ship,\n\n1:25:45.200 --> 1:25:57.360\n somebody has a bright idea. And so we really, really must get that in. We did that successfully\n\n1:25:57.360 --> 1:26:05.680\n with the STL. We got the standard library that gives us all the STL stuff. That basically,\n\n1:26:05.680 --> 1:26:11.520\n I think it saved C++. It was beautiful. And then people tried it with other things\n\n1:26:11.520 --> 1:26:17.520\n and it didn't work so well. They got things in, but it wasn't as dramatic and it took longer and\n\n1:26:17.520 --> 1:26:26.720\n longer and longer. So after C++ 11, which was a huge improvement and what, basically what most\n\n1:26:26.720 --> 1:26:36.400\n people are using today, we decided never again. And so how do you avoid those slips? And the\n\n1:26:36.400 --> 1:26:46.320\n answer is that you ship more often. So that if you have a slip on a 10 year cycle, by the time\n\n1:26:46.320 --> 1:26:52.960\n you know it's a slip, there's 11 years till you get it. Now with a three year cycle, there is\n\n1:26:52.960 --> 1:27:02.640\n about three or four years till you get it. Like the delay between feature freeze and shipping. So\n\n1:27:02.640 --> 1:27:10.880\n you always get one or two years more. And so we shipped 14 on time, we shipped 17 on time,\n\n1:27:10.880 --> 1:27:21.680\n and we ship, we will ship 20 on time. It'll happen. And furthermore, this gives a predictability\n\n1:27:21.680 --> 1:27:26.320\n that allows the implementers, the compiler implementers, the library implementers,\n\n1:27:26.320 --> 1:27:34.640\n they have a target and they deliver on it. 11 took two years before most compilers were good\n\n1:27:34.640 --> 1:27:44.640\n enough. 14, most compilers were actually getting pretty good in 14. 17, everybody shipped in 17.\n\n1:27:45.360 --> 1:27:53.200\n We are going to have at least almost everybody ship almost everything in 20. And I know this\n\n1:27:53.200 --> 1:28:00.480\n and I know this because they're shipping in 19. Predictability is good. Delivery on time is good.\n\n1:28:01.040 --> 1:28:03.840\n And so yeah. That's great. That's how it works.\n\n1:28:05.920 --> 1:28:12.560\n There's a lot of features that came in in C++ 11. There's a lot of features at the birth of C++\n\n1:28:13.200 --> 1:28:20.240\n that were amazing and ideas with concepts in 2020. What to you is the most,\n\n1:28:20.240 --> 1:28:32.640\n just to you personally, beautiful or just you sit back and think, wow, that's just nice and clean\n\n1:28:32.640 --> 1:28:41.680\n feature of C++? I have written two papers for the History of Programming Languages Conference,\n\n1:28:41.680 --> 1:28:47.520\n which basically asked me such questions. And I'm writing a third one, which I will deliver\n\n1:28:47.520 --> 1:28:53.440\n at the History of Programming Languages Conference in London next year. So I've been thinking about\n\n1:28:53.440 --> 1:29:00.320\n that. And there is one clear answer. Constructors and destructors. The way a constructor can\n\n1:29:00.320 --> 1:29:08.400\n establish the environment for the use of a type for an object and the destructor that cleans up\n\n1:29:08.400 --> 1:29:15.120\n any messes at the end of it. That is key to C++. That's why we don't have to use garbage\n\n1:29:15.120 --> 1:29:22.640\n collection. That's how we can get predictable performance. That's how you can get the minimal\n\n1:29:22.640 --> 1:29:31.520\n overhead in many, many cases, and have really clean types. It's the idea of constructor destructor\n\n1:29:31.520 --> 1:29:40.480\n pairs. Sometimes it comes out under the name RAII. Resource acquisition is initialization,\n\n1:29:40.480 --> 1:29:45.280\n which is the idea that you grab resources in the constructor and release them in destructor.\n\n1:29:46.560 --> 1:29:53.200\n It's also the best example of why I shouldn't be in advertising. I get the best idea and I call it\n\n1:29:53.200 --> 1:29:59.520\n resource acquisition is initialization. Not the greatest naming I've ever heard.\n\n1:29:59.520 --> 1:30:08.880\n Not the greatest naming I've ever heard. So it's types, abstraction of types.\n\n1:30:11.040 --> 1:30:18.000\n You said, I want to create my own types. So types is an essential part of C++ and making them\n\n1:30:18.000 --> 1:30:27.760\n efficient is the key part. And to you, this is almost getting philosophical, but the construction\n\n1:30:27.760 --> 1:30:35.760\n and the destruction, the creation of an instance of a type and the freeing of resources from that\n\n1:30:36.400 --> 1:30:45.200\n instance of a type is what defines the object. It's almost like birth and death is what defines\n\n1:30:45.200 --> 1:30:53.600\n human life. That's right. By the way, philosophy is important. You can't do good language design\n\n1:30:53.600 --> 1:30:58.080\n without philosophy because what you are determining is what people can express and how.\n\n1:30:59.200 --> 1:31:08.160\n This is very important. By the way, constructors destructors came into C++ in 79 in about the\n\n1:31:08.160 --> 1:31:14.080\n second week of my work with what was then called C of the classes. It is a fundamental idea.\n\n1:31:15.120 --> 1:31:21.200\n Next comes the fact that you need to control copying because once you control, as you said,\n\n1:31:21.200 --> 1:31:28.400\n birth and death, you have to control taking copies, which is another way of creating an object.\n\n1:31:29.200 --> 1:31:35.680\n And finally, you have to be able to move things around so you get the move operations. And that's\n\n1:31:35.680 --> 1:31:45.440\n the set of key operations you can define on a C++ type. And so to you, those things are just\n\n1:31:45.440 --> 1:31:54.240\n just a beautiful part of C++ that is at the core of it all. Yes. You mentioned that you hope there\n\n1:31:54.240 --> 1:32:00.000\n will be one unified set of guidelines in the future for how to construct a programming language.\n\n1:32:00.000 --> 1:32:07.280\n So perhaps not one programming language, but a unification of how we build programming languages,\n\n1:32:08.480 --> 1:32:13.840\n if you remember such statements. I have some trouble remembering it, but I know the origin\n\n1:32:13.840 --> 1:32:19.360\n of that idea. So maybe you can talk about sort of C++ has been improving. There's been a lot\n\n1:32:19.360 --> 1:32:25.200\n of programming language. Do you, where does the arc of history taking us? Do you hope that there\n\n1:32:25.200 --> 1:32:30.560\n is a unification about the languages with which we communicate in the digital space?\n\n1:32:32.560 --> 1:32:42.400\n Well, I think that languages should be designed not by clobbering language features together and\n\n1:32:42.400 --> 1:32:51.440\n and doing slightly different versions of somebody else's ideas, but through the creation of a set of\n\n1:32:53.120 --> 1:33:01.360\n principles, rules of thumbs, whatever you call them. I made them for C++. And we're trying to\n\n1:33:02.560 --> 1:33:07.120\n teach people in the standards committee about these rules, because a lot of people come in\n\n1:33:07.120 --> 1:33:12.720\n and says, I've got a great idea. Let's put it in the language. And then you have to ask, why does\n\n1:33:12.720 --> 1:33:18.240\n it fit in the language? Why does it fit in this language? It may fit in another language and not\n\n1:33:18.240 --> 1:33:23.520\n here, or it may fit here and not the other language. So you have to work from a set of\n\n1:33:23.520 --> 1:33:33.920\n principles and you have to develop that set of principles. And one example that I sometimes\n\n1:33:33.920 --> 1:33:42.640\n remember is I was sitting down with some of the designers of Common Lisp and we were talking about\n\n1:33:43.600 --> 1:33:50.880\n languages and language features. And obviously we didn't agree about anything because, well,\n\n1:33:50.880 --> 1:33:58.160\n Lisp is not C++ and vice versa. It's too many parentheses. But suddenly we started making\n\n1:33:58.160 --> 1:34:06.560\n progress. I said, I had this problem and I developed it according to these ideas. And\n\n1:34:06.560 --> 1:34:11.680\n they said, why? We had that problem, different problem, and we developed it with the same kind\n\n1:34:11.680 --> 1:34:21.440\n of principles. And so we worked through large chunks of C++ and large chunks of Common Lisp\n\n1:34:21.440 --> 1:34:29.840\n and figured out we actually had similar sets of principles of how to do it. But the constraints\n\n1:34:29.840 --> 1:34:37.600\n on our designs were very different and the aims for the usage was very different. But there was\n\n1:34:37.600 --> 1:34:45.200\n commonality in the way you reason about language features and the fundamental principles you are\n\n1:34:45.200 --> 1:34:52.240\n trying to do. So do you think that's possible? So there, just like there is perhaps a unified\n\n1:34:52.240 --> 1:35:00.880\n theory of physics, of the fundamental forces of physics, that I'm sure there is commonalities\n\n1:35:00.880 --> 1:35:06.960\n among the languages, but there's also people involved that help drive the development of these\n\n1:35:06.960 --> 1:35:16.880\n languages. Do you have a hope or an optimism that there will be a unification? If you think about\n\n1:35:16.880 --> 1:35:22.640\n physics and Einstein towards a simplified language, do you think that's possible?\n\n1:35:24.560 --> 1:35:32.640\n Let's remember sort of modern physics, I think, started with Galileo in the 1300s. So they've had\n\n1:35:32.640 --> 1:35:43.920\n 700 years to get going. Modern computing started in about 49. We've got, what is it, 70 years. They\n\n1:35:43.920 --> 1:35:52.640\n have 10 times. Furthermore, they are not as bothered with people using physics the way\n\n1:35:52.640 --> 1:36:01.680\n we are worried about programming is done by humans. So each have problems and constraints\n\n1:36:01.680 --> 1:36:09.680\n the others have, but we are very immature compared to physics. So I would look at sort of the\n\n1:36:09.680 --> 1:36:18.080\n philosophical level and look for fundamental principles. Like you don't leak resources,\n\n1:36:18.080 --> 1:36:29.280\n you shouldn't. You don't take errors at runtime that you don't need to. You don't violate some\n\n1:36:29.280 --> 1:36:34.160\n kind of type system. There's many kinds of type systems, but when you have one, you don't break it,\n\n1:36:35.760 --> 1:36:43.600\n etc., etc. There will be quite a few, and it will not be the same for all languages. But I think\n\n1:36:44.560 --> 1:36:52.000\n if we step back at some kind of philosophical level, we would be able to agree on sets of\n\n1:36:52.000 --> 1:37:04.320\n principles that applied to sets of problem areas. And within an area of use, like in C++'s case,\n\n1:37:05.280 --> 1:37:12.480\n what used to be called systems programming, the area between the hardware and the fluffier parts\n\n1:37:12.480 --> 1:37:19.200\n of the system, you might very well see a convergence. So these days you see Rust having\n\n1:37:19.200 --> 1:37:27.120\n adopted RAII and sometimes accuse me for having borrowed it 20 years before they discovered it.\n\n1:37:27.120 --> 1:37:38.080\n But we're seeing some kind of convergence here instead of relying on garbage collection all the\n\n1:37:38.080 --> 1:37:46.160\n time. The garbage collection languages are doing things like the dispose patterns and such that\n\n1:37:46.160 --> 1:37:52.480\n imitate some of the construction destruction stuff. And they're trying not to use the garbage\n\n1:37:52.480 --> 1:37:58.320\n collection all the time and things like that. So there's a conversion. But I think we have to step\n\n1:37:58.320 --> 1:38:03.040\n back to the philosophical level, agree on principles, and then we'll see some conversions,\n\n1:38:04.320 --> 1:38:10.720\n convergences. And it will be application domain specific.\n\n1:38:10.720 --> 1:38:16.560\n So a crazy question, but I work a lot with machine learning, with deep learning. I'm not sure if you\n\n1:38:16.560 --> 1:38:23.920\n touch that world that much, but you could think of programming as a thing that takes some input.\n\n1:38:24.480 --> 1:38:29.120\n A programming is the task of creating a program and a program takes some input and produces some\n\n1:38:29.120 --> 1:38:37.600\n output. So machine learning systems train on data in order to be able to take an input and produce\n\n1:38:37.600 --> 1:38:48.640\n output. But they're messy, fuzzy things, much like we as children grow up. We take some input,\n\n1:38:48.640 --> 1:38:53.760\n we make some output, but we're noisy. We mess up a lot. We're definitely not reliable. Biological\n\n1:38:53.760 --> 1:39:01.120\n system are a giant mess. So there's a sense in which machine learning is a kind of way of\n\n1:39:01.120 --> 1:39:11.360\n programming, but just fuzzy. It's very, very, very different than C++. Because C++ is just like you\n\n1:39:11.360 --> 1:39:18.240\n said, it's extremely reliable, it's efficient, you can measure it, you can test it in a bunch of\n\n1:39:18.240 --> 1:39:26.080\n different ways. With biological systems or machine learning systems, you can't say much except sort\n\n1:39:26.080 --> 1:39:34.400\n of empirically saying that 99.8% of the time, it seems to work. What do you think about this fuzzy\n\n1:39:34.400 --> 1:39:41.760\n kind of programming? Do you even see it as programming? Is it totally another kind of world?\n\n1:39:41.760 --> 1:39:48.640\n I think it's a different kind of world. And it is fuzzy. And in my domain, I don't like fuzziness.\n\n1:39:48.640 --> 1:39:56.560\n That is, people say things like they want everybody to be able to program. But I don't\n\n1:39:56.560 --> 1:40:06.400\n want everybody to program my airplane controls or the car controls. I want that to be done by\n\n1:40:06.400 --> 1:40:13.520\n engineers. I want that to be done with people that are specifically educated and trained for doing\n\n1:40:13.520 --> 1:40:20.400\n building things. And it is not for everybody. Similarly, a language like C++ is not for\n\n1:40:20.400 --> 1:40:29.680\n everybody. It is generated to be a sharp and effective tool for professionals, basically,\n\n1:40:30.240 --> 1:40:37.680\n and definitely for people who aim at some kind of precision. You don't have people doing\n\n1:40:37.680 --> 1:40:44.560\n calculations without understanding math. Counting on your fingers is not going to cut it if you want\n\n1:40:44.560 --> 1:40:56.560\n to fly to the moon. And so there are areas where an 84% accuracy rate, 16% false positive rate,\n\n1:40:56.560 --> 1:41:09.360\n is perfectly acceptable and where people will probably get no more than 70. You said 98%. What\n\n1:41:09.360 --> 1:41:16.320\n I have seen is more like 84. And by really a lot of blood, sweat, and tears, you can get up to 92.5.\n\n1:41:16.320 --> 1:41:27.920\n So this is fine if it is, say, prescreening stuff before the human look at it. It is not good enough\n\n1:41:27.920 --> 1:41:36.000\n for life threatening situations. And so there's lots of areas where the fuzziness is perfectly\n\n1:41:36.000 --> 1:41:40.400\n acceptable and good and better than humans, cheaper than humans, cheaper than humans.\n\n1:41:40.400 --> 1:41:47.440\n But it's not the kind of engineering stuff I'm mostly interested in. I worry a bit about\n\n1:41:48.000 --> 1:41:53.200\n machine learning in the context of cars. You know much more about this than I do.\n\n1:41:53.200 --> 1:41:54.160\n I worry too.\n\n1:41:54.160 --> 1:42:02.880\n But I'm sort of an amateur here. I've read some of the papers, but I've not ever done it. And the\n\n1:42:02.880 --> 1:42:12.320\n idea that scares me the most is the one I have heard, and I don't know how common it is, that\n\n1:42:14.640 --> 1:42:24.960\n you have this AI system, machine learning, all of these trained neural nets. And when there's\n\n1:42:24.960 --> 1:42:32.560\n something that's too complicated, they ask the human for help. But the human is reading a book or\n\n1:42:32.560 --> 1:42:41.040\n asleep, and he has 30 seconds or three seconds to figure out what the problem was that the AI\n\n1:42:41.040 --> 1:42:48.400\n system couldn't handle and do the right thing. This is scary. I mean, how do you do the cutting\n\n1:42:48.400 --> 1:42:58.000\n work between the machine and the human? It's very, very difficult. And for the designer of\n\n1:42:58.000 --> 1:43:05.120\n one of the most reliable, efficient, and powerful programming languages, C++, I can understand why\n\n1:43:05.120 --> 1:43:11.920\n that world is actually unappealing. It is for most engineers. To me, it's extremely\n\n1:43:11.920 --> 1:43:18.080\n appealing because we don't know how to get that interaction right. But I think it's possible. But\n\n1:43:18.080 --> 1:43:24.320\n it's very, very hard. It is. And I was stating a problem, not a solution. That is impossible.\n\n1:43:24.320 --> 1:43:29.120\n I mean, I would much rather never rely on the human. If you're driving a nuclear reactor,\n\n1:43:29.120 --> 1:43:35.920\n if you're or an autonomous vehicle, it's much better to design systems written in C++ than\n\n1:43:35.920 --> 1:43:44.800\n never ask human for help. Let's just get one fact in. Yeah. All of this AI stuff is on top of C++.\n\n1:43:47.760 --> 1:43:53.360\n So that's one reason I have to keep a weather eye out on what's going on in that field. But\n\n1:43:53.360 --> 1:43:58.400\n I will never become an expert in that area. But it's a good example of how you separate\n\n1:43:58.400 --> 1:44:05.920\n different areas of applications and you have to have different tools, different principles. And\n\n1:44:05.920 --> 1:44:11.200\n then they interact. No major system today is written in one language. And there are good\n\n1:44:11.200 --> 1:44:20.800\n reasons for that. When you look back at your life work, what is a moment? What is a\n\n1:44:20.800 --> 1:44:27.200\n event creation that you're really proud of? They say, damn, I did pretty good there.\n\n1:44:29.040 --> 1:44:36.880\n Is it as obvious as the creation of C++? It's obvious. I've spent a lot of time with C++. And\n\n1:44:37.920 --> 1:44:43.120\n there's a combination of a few good ideas, a lot of hard work, and a bit of work that I've done.\n\n1:44:43.120 --> 1:44:50.800\n And I've tried to get away from it a few times, but I get dragged in again, partly because I'm\n\n1:44:50.800 --> 1:44:58.400\n most effective in this area and partly because what I do has much more impact if I do it in\n\n1:44:58.400 --> 1:45:05.120\n the context of C++. I have four and a half million people that pick it up tomorrow if I\n\n1:45:05.120 --> 1:45:13.840\n get something right. If I did it in another field, I would have to start learning, then I have to\n\n1:45:13.840 --> 1:45:21.760\n build it and then we'll see if anybody wants to use it. One of the things that has kept me going\n\n1:45:21.760 --> 1:45:29.280\n for all of these years is one, the good things that people do with it and the interesting things\n\n1:45:29.280 --> 1:45:36.160\n they do with it. And also, I get to see a lot of interesting stuff and talk to a lot of interesting\n\n1:45:36.160 --> 1:45:46.400\n people. I mean, if it has just been statements on paper on a screen, I don't think I could have kept\n\n1:45:46.400 --> 1:45:54.400\n going. But I get to see the telescopes up on Mauna Kea and I actually went and see how Ford built\n\n1:45:54.400 --> 1:46:05.440\n cars and I got to JPL and see how they do the Mars rovers. There's so much cool stuff going on. And\n\n1:46:05.440 --> 1:46:10.480\n most of the cool stuff is done by pretty nice people and sometimes in very nice places.\n\n1:46:10.480 --> 1:46:25.360\n Cambridge, Sophia, Silicon Valley. There's more to it than just code. But code is central.\n\n1:46:25.360 --> 1:46:32.480\n On top of the code are the people in very nice places. Well, I think I speak for millions of\n\n1:46:32.480 --> 1:46:40.800\n people, Yaron, in saying thank you for creating this language that so many systems are built on\n\n1:46:40.800 --> 1:46:47.360\n top of that make a better world. So thank you and thank you for talking today. Yeah, thanks.\n\n1:46:47.360 --> 1:47:03.040\n And we'll make it even better. Good.\n\n"
}