{
  "title": "Guido van Rossum: Python | Lex Fridman Podcast #6",
  "id": "ghwaIiE3Nd8",
  "transcript": "WEBVTT\n\n00:00.000 --> 00:05.680\n The following is a conversation with Guido van Rossum, creator of Python, one of the most popular\n\n00:05.680 --> 00:11.120\n programming languages in the world, used in almost any application that involves computers\n\n00:11.120 --> 00:17.760\n from web back end development to psychology, neuroscience, computer vision, robotics, deep\n\n00:17.760 --> 00:24.560\n learning, natural language processing, and almost any subfield of AI. This conversation is part of\n\n00:24.560 --> 00:29.280\n MIT course on artificial general intelligence and the artificial intelligence podcast.\n\n00:29.280 --> 00:36.080\n If you enjoy it, subscribe on YouTube, iTunes, or your podcast provider of choice, or simply connect\n\n00:36.080 --> 00:44.720\n with me on Twitter at Lex Friedman, spelled F R I D. And now, here's my conversation with Guido van\n\n00:44.720 --> 00:53.120\n Rossum. You were born in the Netherlands in 1956. Your parents and the world around you was deeply\n\n00:53.120 --> 01:00.080\n deeply impacted by World War Two, as was my family from the Soviet Union. So with that context,\n\n01:02.000 --> 01:07.360\n what is your view of human nature? Are some humans inherently good,\n\n01:07.360 --> 01:12.240\n and some inherently evil? Or do we all have both good and evil within us?\n\n01:12.240 --> 01:23.920\n Guido van Rossum Ouch, I did not expect such a deep one. I, I guess we all have good and evil\n\n01:24.880 --> 01:31.440\n potential in us. And a lot of it depends on circumstances and context.\n\n01:31.440 --> 01:38.800\n Peter Bell out of that world, at least on the Soviet Union side in Europe, sort of out of\n\n01:38.800 --> 01:46.480\n suffering, out of challenge, out of that kind of set of traumatic events, often emerges beautiful\n\n01:46.480 --> 01:53.200\n art, music, literature. In an interview I read or heard, you said you enjoyed Dutch literature\n\n01:54.320 --> 01:59.760\n when you were a child. Can you tell me about the books that had an influence on you in your\n\n01:59.760 --> 02:01.520\n childhood? Guido van Rossum\n\n02:01.520 --> 02:09.120\n Well, with as a teenager, my favorite writer was my favorite Dutch author was a guy named Willem\n\n02:09.120 --> 02:19.440\n Frederik Hermans, who's writing, certainly his early novels were all about sort of\n\n02:19.440 --> 02:30.480\n ambiguous things that happened during World War Two. I think he was a young adult during that time.\n\n02:31.600 --> 02:40.800\n And he wrote about it a lot, and very interesting, very good books, I thought, I think.\n\n02:40.800 --> 02:42.560\n Peter Bell In a nonfiction way?\n\n02:42.560 --> 02:46.400\n Guido van Rossum No, it was all fiction, but it was\n\n02:46.400 --> 02:52.640\n very much set in the ambiguous world of resistance against the Germans,\n\n02:54.560 --> 03:03.840\n where often you couldn't tell whether someone was truly in the resistance or really a spy for the\n\n03:03.840 --> 03:11.280\n Germans. And some of the characters in his novels sort of crossed that line, and you never really\n\n03:11.280 --> 03:13.840\n find out what exactly happened.\n\n03:13.840 --> 03:16.880\n Peter Bell And in his novels, there's always a\n\n03:16.880 --> 03:22.160\n good guy and a bad guy, the nature of good and evil. Is it clear there's a hero?\n\n03:22.160 --> 03:25.120\n Guido van Rossum No, his heroes are often more,\n\n03:25.120 --> 03:34.000\n his main characters are often anti heroes. And so they're not very heroic. They're often,\n\n03:36.640 --> 03:40.800\n they fail at some level to accomplish their lofty goals.\n\n03:40.800 --> 03:43.040\n Peter Bell And looking at the trajectory\n\n03:43.040 --> 03:48.880\n through the rest of your life, has literature, Dutch or English or translation had an impact\n\n03:50.560 --> 03:54.160\n outside the technical world that you existed in?\n\n03:54.160 --> 03:59.920\n Guido van Rossum I still read novels.\n\n04:00.640 --> 04:05.200\n I don't think that it impacts me that much directly.\n\n04:05.200 --> 04:07.280\n Peter Bell It doesn't impact your work.\n\n04:07.280 --> 04:10.080\n Guido van Rossum It's a separate world.\n\n04:10.080 --> 04:17.440\n My work is highly technical and sort of the world of art and literature doesn't really\n\n04:17.440 --> 04:19.120\n directly have any bearing on it.\n\n04:19.120 --> 04:22.400\n Peter Bell You don't think there's a creative element\n\n04:22.400 --> 04:26.880\n to the design? You know, some would say design of a language is art.\n\n04:26.880 --> 04:32.160\n Guido van Rossum I'm not disagreeing with that.\n\n04:32.160 --> 04:39.360\n I'm just saying that sort of I don't feel direct influences from more traditional art\n\n04:39.360 --> 04:40.880\n on my own creativity.\n\n04:40.880 --> 04:43.280\n Peter Bell Right. Of course, you don't feel doesn't mean\n\n04:43.280 --> 04:46.000\n it's not somehow deeply there in your subconscious.\n\n04:46.000 --> 04:48.240\n Guido van Rossum Who knows?\n\n04:48.240 --> 04:51.200\n Peter Bell Who knows? So let's go back to your early\n\n04:51.200 --> 04:57.440\n teens. Your hobbies were building electronic circuits, building mechanical models.\n\n04:57.440 --> 05:06.080\n What if you can just put yourself back in the mind of that young Guido 12, 13, 14, was\n\n05:06.080 --> 05:12.240\n that grounded in a desire to create a system? So to create something? Or was it more just\n\n05:12.240 --> 05:14.720\n tinkering? Just the joy of puzzle solving?\n\n05:14.720 --> 05:18.720\n Guido van Rossum I think it was more the latter, actually.\n\n05:18.720 --> 05:29.920\n I maybe towards the end of my high school period, I felt confident enough that that\n\n05:29.920 --> 05:39.120\n I designed my own circuits that were sort of interesting somewhat. But a lot of that\n\n05:39.120 --> 05:46.000\n time, I literally just took a model kit and follow the instructions, putting the things\n\n05:46.000 --> 05:51.680\n together. I mean, I think the first few years that I built electronics kits, I really did\n\n05:51.680 --> 05:59.760\n not have enough understanding of sort of electronics to really understand what I was doing. I mean,\n\n05:59.760 --> 06:06.480\n I could debug it, and I could sort of follow the instructions very carefully, which has\n\n06:06.480 --> 06:14.560\n always stayed with me. But I had a very naive model of, like, how do I build a circuit?\n\n06:14.560 --> 06:22.800\n Of, like, how a transistor works? And I don't think that in those days, I had any understanding\n\n06:22.800 --> 06:32.560\n of coils and capacitors, which actually sort of was a major problem when I started to build\n\n06:32.560 --> 06:39.840\n more complex digital circuits, because I was unaware of the sort of the analog part of\n\n06:39.840 --> 06:50.080\n the \u2013 how they actually work. And I would have things that \u2013 the schematic looked\n\n06:50.080 --> 06:57.440\n \u2013 everything looked fine, and it didn't work. And what I didn't realize was that\n\n06:57.440 --> 07:02.720\n there was some megahertz level oscillation that was throwing the circuit off, because\n\n07:02.720 --> 07:13.360\n I had a sort of \u2013 two wires were too close, or the switches were kind of poorly built.\n\n07:13.360 --> 07:19.280\n But through that time, I think it's really interesting and instructive to think about,\n\n07:19.280 --> 07:24.600\n because echoes of it are in this time now. So in the 1970s, the personal computer was\n\n07:24.600 --> 07:33.200\n being born. So did you sense, in tinkering with these circuits, did you sense the encroaching\n\n07:33.200 --> 07:39.320\n revolution in personal computing? So if at that point, we would sit you down and ask\n\n07:39.320 --> 07:46.040\n you to predict the 80s and the 90s, do you think you would be able to do so successfully\n\n07:46.040 --> 07:55.560\n to unroll the process that's happening? No, I had no clue. I remember, I think, in\n\n07:55.560 --> 08:03.060\n the summer after my senior year \u2013 or maybe it was the summer after my junior year \u2013 well,\n\n08:03.060 --> 08:11.600\n at some point, I think, when I was 18, I went on a trip to the Math Olympiad in Eastern\n\n08:11.600 --> 08:16.920\n Europe, and there was like \u2013 I was part of the Dutch team, and there were other nerdy\n\n08:16.920 --> 08:23.040\n kids that sort of had different experiences, and one of them told me about this amazing\n\n08:23.040 --> 08:31.840\n thing called a computer. And I had never heard that word. My own explorations in electronics\n\n08:31.840 --> 08:40.420\n were sort of about very simple digital circuits, and I had sort of \u2013 I had the idea that\n\n08:40.420 --> 08:49.760\n I somewhat understood how a digital calculator worked. And so there is maybe some echoes\n\n08:49.760 --> 08:56.440\n of computers there, but I never made that connection. I didn't know that when my parents\n\n08:56.440 --> 09:03.520\n were paying for magazine subscriptions using punched cards, that there was something called\n\n09:03.520 --> 09:08.260\n a computer that was involved that read those cards and transferred the money between accounts.\n\n09:08.260 --> 09:15.880\n I was also not really interested in those things. It was only when I went to university\n\n09:15.880 --> 09:23.120\n to study math that I found out that they had a computer, and students were allowed to use\n\n09:23.120 --> 09:24.120\n it.\n\n09:24.120 --> 09:27.800\n And there were some \u2013 you're supposed to talk to that computer by programming it.\n\n09:27.800 --> 09:29.920\n What did that feel like, finding \u2013\n\n09:29.920 --> 09:35.440\n Yeah, that was the only thing you could do with it. The computer wasn't really connected\n\n09:35.440 --> 09:41.400\n to the real world. The only thing you could do was sort of \u2013 you typed your program\n\n09:41.400 --> 09:47.840\n on a bunch of punched cards. You gave the punched cards to the operator, and an hour\n\n09:47.840 --> 09:55.520\n later the operator gave you back your printout. And so all you could do was write a program\n\n09:55.520 --> 10:04.080\n that did something very abstract. And I don't even remember what my first forays into programming\n\n10:04.080 --> 10:13.440\n were, but they were sort of doing simple math exercises and just to learn how a programming\n\n10:13.440 --> 10:15.560\n language worked.\n\n10:15.560 --> 10:21.680\n Did you sense, okay, first year of college, you see this computer, you're able to have\n\n10:21.680 --> 10:29.420\n a program and it generates some output. Did you start seeing the possibility of this,\n\n10:29.420 --> 10:34.920\n or was it a continuation of the tinkering with circuits? Did you start to imagine that\n\n10:34.920 --> 10:42.460\n one, the personal computer, but did you see it as something that is a tool, like a word\n\n10:42.460 --> 10:47.160\n processing tool, maybe for gaming or something? Or did you start to imagine that it could\n\n10:47.160 --> 10:53.860\n be going to the world of robotics, like the Frankenstein picture that you could create\n\n10:53.860 --> 10:59.640\n an artificial being? There's like another entity in front of you. You did not see the\n\n10:59.640 --> 11:00.640\n computer.\n\n11:00.640 --> 11:05.840\n I don't think I really saw it that way. I was really more interested in the tinkering.\n\n11:05.840 --> 11:14.920\n It's maybe not a sort of a complete coincidence that I ended up sort of creating a programming\n\n11:14.920 --> 11:20.360\n language which is a tool for other programmers. I've always been very focused on the sort\n\n11:20.360 --> 11:28.920\n of activity of programming itself and not so much what happens with the program you\n\n11:28.920 --> 11:29.920\n write.\n\n11:29.920 --> 11:30.920\n Right.\n\n11:30.920 --> 11:37.800\n I do remember, and I don't remember, maybe in my second or third year, probably my second\n\n11:37.800 --> 11:46.680\n actually, someone pointed out to me that there was this thing called Conway's Game of Life.\n\n11:46.680 --> 11:50.480\n You're probably familiar with it. I think \u2013\n\n11:50.480 --> 11:53.200\n In the 70s, I think is when they came up with it.\n\n11:53.200 --> 12:00.840\n So there was a Scientific American column by someone who did a monthly column about\n\n12:00.840 --> 12:06.580\n mathematical diversions. I'm also blanking out on the guy's name. It was very famous\n\n12:06.580 --> 12:12.440\n at the time and I think up to the 90s or so. And one of his columns was about Conway's\n\n12:12.440 --> 12:18.160\n Game of Life and he had some illustrations and he wrote down all the rules and sort of\n\n12:18.160 --> 12:23.720\n there was the suggestion that this was philosophically interesting, that that was why Conway had\n\n12:23.720 --> 12:31.480\n called it that. And all I had was like the two pages photocopy of that article. I don't\n\n12:31.480 --> 12:40.200\n even remember where I got it. But it spoke to me and I remember implementing a version\n\n12:40.200 --> 12:49.000\n of that game for the batch computer we were using where I had a whole Pascal program that\n\n12:49.000 --> 12:56.480\n sort of read an initial situation from input and read some numbers that said do so many\n\n12:56.480 --> 13:05.960\n generations and print every so many generations and then out would come pages and pages of\n\n13:05.960 --> 13:08.480\n sort of things.\n\n13:08.480 --> 13:18.360\n I remember much later I've done a similar thing using Python but that original version\n\n13:18.360 --> 13:27.700\n I wrote at the time I found interesting because I combined it with some trick I had learned\n\n13:27.700 --> 13:36.000\n during my electronics hobbyist times. I essentially first on paper I designed a simple circuit\n\n13:36.000 --> 13:45.780\n built out of logic gates that took nine bits of input which is sort of the cell and its\n\n13:45.780 --> 13:54.040\n neighbors and produced a new value for that cell and it's like a combination of a half\n\n13:54.040 --> 14:01.040\n adder and some other clipping. It's actually a full adder. And so I had worked that out\n\n14:01.040 --> 14:10.520\n and then I translated that into a series of Boolean operations on Pascal integers where\n\n14:10.520 --> 14:21.740\n you could use the integers as bitwise values. And so I could basically generate 60 bits\n\n14:21.740 --> 14:28.800\n of a generation in like eight instructions or so.\n\n14:28.800 --> 14:29.800\n Nice.\n\n14:29.800 --> 14:32.560\n So I was proud of that.\n\n14:32.560 --> 14:38.120\n It's funny that you mentioned, so for people who don't know Conway's Game of Life, it's\n\n14:38.120 --> 14:44.840\n a cellular automata where there's single compute units that kind of look at their neighbors\n\n14:44.840 --> 14:50.080\n and figure out what they look like in the next generation based on the state of their\n\n14:50.080 --> 14:57.840\n neighbors and this is deeply distributed system in concept at least. And then there's simple\n\n14:57.840 --> 15:04.400\n rules that all of them follow and somehow out of this simple rule when you step back\n\n15:04.400 --> 15:13.160\n and look at what occurs, it's beautiful. There's an emergent complexity. Even though the underlying\n\n15:13.160 --> 15:17.440\n rules are simple, there's an emergent complexity. Now the funny thing is you've implemented\n\n15:17.440 --> 15:23.660\n this and the thing you're commenting on is you're proud of a hack you did to make it\n\n15:23.660 --> 15:30.800\n run efficiently. When you're not commenting on, it's a beautiful implementation, you're\n\n15:30.800 --> 15:36.780\n not commenting on the fact that there's an emergent complexity that you've coded a simple\n\n15:36.780 --> 15:42.960\n program and when you step back and you print out the following generation after generation,\n\n15:42.960 --> 15:48.400\n that's stuff that you may have not predicted would happen is happening.\n\n15:48.400 --> 15:53.600\n And is that magic? I mean, that's the magic that all of us feel when we program. When\n\n15:53.600 --> 15:59.240\n you create a program and then you run it and whether it's Hello World or it shows something\n\n15:59.240 --> 16:03.840\n on screen, if there's a graphical component, are you seeing the magic in the mechanism\n\n16:03.840 --> 16:05.200\n of creating that?\n\n16:05.200 --> 16:14.440\n I think I went back and forth. As a student, we had an incredibly small budget of computer\n\n16:14.440 --> 16:20.280\n time that we could use. It was actually measured. I once got in trouble with one of my professors\n\n16:20.280 --> 16:29.640\n because I had overspent the department's budget. It's a different story.\n\n16:29.640 --> 16:36.900\n I actually wanted the efficient implementation because I also wanted to explore what would\n\n16:36.900 --> 16:48.560\n happen with a larger number of generations and a larger size of the board. Once the implementation\n\n16:48.560 --> 16:57.000\n was flawless, I would feed it different patterns and then I think maybe there was a follow\n\n16:57.000 --> 17:03.620\n up article where there were patterns that were like gliders, patterns that repeated\n\n17:03.620 --> 17:13.200\n themselves after a number of generations but translated one or two positions to the right\n\n17:13.200 --> 17:21.720\n or up or something like that. I remember things like glider guns. Well, you can Google Conway's\n\n17:21.720 --> 17:27.560\n Game of Life. People still go aww and ooh over it.\n\n17:27.560 --> 17:32.680\n For a reason because it's not really well understood why. I mean, this is what Stephen\n\n17:32.680 --> 17:40.240\n Wolfram is obsessed about. We don't have the mathematical tools to describe the kind of\n\n17:40.240 --> 17:45.120\n complexity that emerges in these kinds of systems. The only way you can do is to run\n\n17:45.120 --> 17:47.120\n it.\n\n17:47.120 --> 17:55.720\n I'm not convinced that it's sort of a problem that lends itself to classic mathematical\n\n17:55.720 --> 17:59.920\n analysis.\n\n17:59.920 --> 18:05.120\n One theory of how you create an artificial intelligence or artificial being is you kind\n\n18:05.120 --> 18:10.120\n of have to, same with the Game of Life, you kind of have to create a universe and let\n\n18:10.120 --> 18:17.520\n it run. That creating it from scratch in a design way, coding up a Python program that\n\n18:17.520 --> 18:22.760\n creates a fully intelligent system may be quite challenging. You might need to create\n\n18:22.760 --> 18:27.120\n a universe just like the Game of Life.\n\n18:27.120 --> 18:33.200\n You might have to experiment with a lot of different universes before there is a set\n\n18:33.200 --> 18:41.480\n of rules that doesn't essentially always just end up repeating itself in a trivial\n\n18:41.480 --> 18:42.480\n way.\n\n18:42.480 --> 18:49.840\n Yeah, and Stephen Wolfram works with these simple rules, says that it's kind of surprising\n\n18:49.840 --> 18:55.280\n how quickly you find rules that create interesting things. You shouldn't be able to, but somehow\n\n18:55.280 --> 19:02.120\n you do. And so maybe our universe is laden with rules that will create interesting things\n\n19:02.120 --> 19:07.440\n that might not look like humans, but emergent phenomena that's interesting may not be as\n\n19:07.440 --> 19:09.440\n difficult to create as we think.\n\n19:09.440 --> 19:10.440\n Sure.\n\n19:10.440 --> 19:17.440\n But let me sort of ask, at that time, some of the world, at least in popular press, was\n\n19:17.440 --> 19:25.680\n kind of captivated, perhaps at least in America, by the idea of artificial intelligence, that\n\n19:25.680 --> 19:33.240\n these computers would be able to think pretty soon. And did that touch you at all? In science\n\n19:33.240 --> 19:37.800\n fiction or in reality in any way?\n\n19:37.800 --> 19:49.000\n I didn't really start reading science fiction until much, much later. I think as a teenager\n\n19:49.000 --> 19:54.520\n I read maybe one bundle of science fiction stories.\n\n19:54.520 --> 19:57.960\n Was it in the background somewhere, like in your thoughts?\n\n19:57.960 --> 20:04.720\n That sort of the using computers to build something intelligent always felt to me, because\n\n20:04.720 --> 20:12.920\n I felt I had so much understanding of what actually goes on inside a computer. I knew\n\n20:12.920 --> 20:22.880\n how many bits of memory it had and how difficult it was to program. And sort of, I didn't believe\n\n20:22.880 --> 20:30.560\n at all that you could just build something intelligent out of that, that would really\n\n20:30.560 --> 20:40.600\n sort of satisfy my definition of intelligence. I think the most influential thing that I\n\n20:40.600 --> 20:48.680\n read in my early twenties was G\u00f6del Escherbach. That was about consciousness, and that was\n\n20:48.680 --> 20:54.040\n a big eye opener in some sense.\n\n20:54.040 --> 21:00.760\n In what sense? So, on your own brain, did you at the time or do you now see your own\n\n21:00.760 --> 21:07.720\n brain as a computer? Or is there a total separation of the way? So yeah, you're very pragmatically\n\n21:07.720 --> 21:14.600\n practically know the limits of memory, the limits of this sequential computing or weakly\n\n21:14.600 --> 21:21.000\n paralyzed computing, and you just know what we have now, and it's hard to see how it creates.\n\n21:21.000 --> 21:29.920\n But it's also easy to see, it was in the 40s, 50s, 60s, and now at least similarities between\n\n21:29.920 --> 21:31.680\n the brain and our computers.\n\n21:31.680 --> 21:43.200\n Oh yeah, I mean, I totally believe that brains are computers in some sense. I mean, the rules\n\n21:43.200 --> 21:51.200\n they use to play by are pretty different from the rules we can sort of implement in our\n\n21:51.200 --> 22:02.960\n current hardware, but I don't believe in, like, a separate thing that infuses us with\n\n22:02.960 --> 22:10.480\n intelligence or consciousness or any of that. There's no soul, I've been an atheist\n\n22:10.480 --> 22:18.800\n probably from when I was 10 years old, just by thinking a bit about math and the universe,\n\n22:18.800 --> 22:26.640\n and well, my parents were atheists. Now, I know that you could be an atheist and still\n\n22:26.640 --> 22:34.080\n believe that there is something sort of about intelligence or consciousness that cannot\n\n22:34.080 --> 22:44.560\n possibly emerge from a fixed set of rules. I am not in that camp. I totally see that,\n\n22:44.560 --> 22:53.680\n sort of, given how many millions of years evolution took its time, DNA is a particular\n\n22:53.680 --> 23:07.040\n machine that sort of encodes information and an unlimited amount of information in chemical\n\n23:07.040 --> 23:12.320\n form and has figured out a way to replicate itself.\n\n23:12.320 --> 23:16.880\n I thought that that was, maybe it's 300 million years ago, but I thought it was closer\n\n23:16.880 --> 23:25.120\n to half a billion years ago, that that's sort of originated and it hasn't really changed,\n\n23:25.120 --> 23:32.040\n that the sort of the structure of DNA hasn't changed ever since. That is like our binary\n\n23:32.040 --> 23:35.200\n code that we have in hardware. I mean...\n\n23:35.200 --> 23:39.760\n The basic programming language hasn't changed, but maybe the programming itself...\n\n23:39.760 --> 23:48.320\n Obviously, it did sort of, it happened to be a set of rules that was good enough to\n\n23:48.320 --> 23:59.520\n sort of develop endless variability and sort of the idea of self replicating molecules\n\n23:59.520 --> 24:05.360\n competing with each other for resources and one type eventually sort of always taking\n\n24:05.360 --> 24:12.320\n over. That happened before there were any fossils, so we don't know how that exactly\n\n24:12.320 --> 24:17.920\n happened, but I believe it's clear that that did happen.\n\n24:17.920 --> 24:25.360\n Can you comment on consciousness and how you see it? Because I think we'll talk about\n\n24:25.360 --> 24:30.080\n programming quite a bit. We'll talk about, you know, intelligence connecting to programming\n\n24:30.080 --> 24:38.080\n fundamentally, but consciousness is this whole other thing. Do you think about it often as\n\n24:38.080 --> 24:45.440\n a developer of a programming language and as a human?\n\n24:45.440 --> 24:55.000\n Those are pretty sort of separate topics. Sort of my line of work working with programming\n\n24:55.000 --> 25:02.720\n does not involve anything that goes in the direction of developing intelligence or consciousness,\n\n25:02.720 --> 25:13.880\n but sort of privately as an avid reader of popular science writing, I have some thoughts\n\n25:13.880 --> 25:25.680\n which is mostly that I don't actually believe that consciousness is an all or nothing thing.\n\n25:25.680 --> 25:35.960\n I have a feeling that, and I forget what I read that influenced this, but I feel that\n\n25:35.960 --> 25:41.400\n if you look at a cat or a dog or a mouse, they have some form of intelligence. If you\n\n25:41.400 --> 25:54.040\n look at a fish, it has some form of intelligence, and that evolution just took a long time,\n\n25:54.040 --> 26:01.320\n but I feel that the sort of evolution of more and more intelligence that led to sort of\n\n26:01.320 --> 26:12.920\n the human form of intelligence followed the evolution of the senses, especially the visual\n\n26:12.920 --> 26:20.480\n sense. I mean, there is an enormous amount of processing that's needed to interpret\n\n26:20.480 --> 26:28.240\n a scene, and humans are still better at that than computers are.\n\n26:28.240 --> 26:39.660\n And I have a feeling that there is a sort of, the reason that like mammals in particular\n\n26:39.660 --> 26:47.960\n developed the levels of consciousness that they have and that eventually sort of going\n\n26:47.960 --> 26:55.360\n from intelligence to self awareness and consciousness has to do with sort of being a robot that\n\n26:55.360 --> 26:58.920\n has very highly developed senses.\n\n26:58.920 --> 27:04.760\n Has a lot of rich sensory information coming in, so that's a really interesting thought\n\n27:04.760 --> 27:14.200\n that whatever that basic mechanism of DNA, whatever that basic building blocks of programming,\n\n27:14.200 --> 27:21.080\n if you just add more abilities, more high resolution sensors, more sensors, you just\n\n27:21.080 --> 27:26.760\n keep stacking those things on top that this basic programming in trying to survive develops\n\n27:26.760 --> 27:35.000\n very interesting things that start to us humans to appear like intelligence and consciousness.\n\n27:35.000 --> 27:42.280\n As far as robots go, I think that the self driving cars have that sort of the greatest\n\n27:42.280 --> 27:50.400\n opportunity of developing something like that, because when I drive myself, I don't just\n\n27:50.400 --> 27:53.800\n pay attention to the rules of the road.\n\n27:53.800 --> 28:01.220\n I also look around and I get clues from that, oh, this is a shopping district, oh, here's\n\n28:01.220 --> 28:08.960\n an old lady crossing the street, oh, here is someone carrying a pile of mail, there's\n\n28:08.960 --> 28:14.040\n a mailbox, I bet you they're going to cross the street to reach that mailbox.\n\n28:14.040 --> 28:17.520\n And I slow down, and I don't even think about that.\n\n28:17.520 --> 28:25.780\n And so, there is so much where you turn your observations into an understanding of what\n\n28:25.780 --> 28:32.680\n other consciousnesses are going to do, or what other systems in the world are going\n\n28:32.680 --> 28:37.400\n to be, oh, that tree is going to fall.\n\n28:37.400 --> 28:46.800\n I see sort of, I see much more of, I expect somehow that if anything is going to become\n\n28:46.800 --> 28:55.520\n unconscious, it's going to be the self driving car and not the network of a bazillion computers\n\n28:55.520 --> 29:03.160\n in a Google or Amazon data center that are all networked together to do whatever they\n\n29:03.160 --> 29:04.160\n do.\n\n29:04.160 --> 29:09.640\n So, in that sense, so you actually highlight, because that's what I work in Thomas Vehicles,\n\n29:09.640 --> 29:15.600\n you highlight the big gap between what we currently can't do and what we truly need\n\n29:15.600 --> 29:18.500\n to be able to do to solve the problem.\n\n29:18.500 --> 29:24.600\n Under that formulation, then consciousness and intelligence is something that basically\n\n29:24.600 --> 29:30.020\n a system should have in order to interact with us humans, as opposed to some kind of\n\n29:30.020 --> 29:35.280\n abstract notion of a consciousness.\n\n29:35.280 --> 29:39.200\n Consciousness is something that you need to have to be able to empathize, to be able to\n\n29:39.200 --> 29:47.440\n fear, understand what the fear of death is, all these aspects that are important for interacting\n\n29:47.440 --> 29:56.160\n with pedestrians, you need to be able to do basic computation based on our human desires\n\n29:56.160 --> 29:57.160\n and thoughts.\n\n29:57.160 --> 30:02.280\n And if you sort of, yeah, if you look at the dog, the dog clearly knows, I mean, I'm\n\n30:02.280 --> 30:07.340\n not the dog owner, but I have friends who have dogs, the dogs clearly know what the\n\n30:07.340 --> 30:11.400\n humans around them are going to do, or at least they have a model of what those humans\n\n30:11.400 --> 30:14.160\n are going to do and they learn.\n\n30:14.160 --> 30:19.060\n Some dogs know when you're going out and they want to go out with you, they're sad when\n\n30:19.060 --> 30:26.080\n you leave them alone, they cry, they're afraid because they were mistreated when they were\n\n30:26.080 --> 30:31.040\n younger.\n\n30:31.040 --> 30:39.280\n We don't assign sort of consciousness to dogs, or at least not all that much, but I also\n\n30:39.280 --> 30:42.500\n don't think they have none of that.\n\n30:42.500 --> 30:50.360\n So I think it's consciousness and intelligence are not all or nothing.\n\n30:50.360 --> 30:52.780\n The spectrum is really interesting.\n\n30:52.780 --> 30:58.760\n But in returning to programming languages and the way we think about building these\n\n30:58.760 --> 31:03.260\n kinds of things, about building intelligence, building consciousness, building artificial\n\n31:03.260 --> 31:04.260\n beings.\n\n31:04.260 --> 31:10.920\n So I think one of the exciting ideas came in the 17th century and with Leibniz, Hobbes,\n\n31:10.920 --> 31:18.520\n Descartes, where there's this feeling that you can convert all thought, all reasoning,\n\n31:18.520 --> 31:24.480\n all the thing that we find very special in our brains, you can convert all of that into\n\n31:24.480 --> 31:25.480\n logic.\n\n31:25.480 --> 31:30.400\n So you can formalize it, formal reasoning, and then once you formalize everything, all\n\n31:30.400 --> 31:34.400\n of knowledge, then you can just calculate and that's what we're doing with our brains\n\n31:34.400 --> 31:35.400\n is we're calculating.\n\n31:35.400 --> 31:40.240\n So there's this whole idea that this is possible, that this we can actually program.\n\n31:40.240 --> 31:46.520\n But they weren't aware of the concept of pattern matching in the sense that we are aware of\n\n31:46.520 --> 31:47.640\n it now.\n\n31:47.640 --> 31:57.640\n They sort of thought they had discovered incredible bits of mathematics like Newton's calculus\n\n31:57.640 --> 32:06.840\n and their sort of idealism, their sort of extension of what they could do with logic\n\n32:06.840 --> 32:18.000\n and math sort of went along those lines and they thought there's like, yeah, logic.\n\n32:18.000 --> 32:22.020\n There's like a bunch of rules and a bunch of input.\n\n32:22.020 --> 32:28.600\n They didn't realize that how you recognize a face is not just a bunch of rules but is\n\n32:28.600 --> 32:39.160\n a shit ton of data plus a circuit that sort of interprets the visual clues and the context\n\n32:39.160 --> 32:49.400\n and everything else and somehow can massively parallel pattern match against stored rules.\n\n32:49.400 --> 32:56.320\n I mean, if I see you tomorrow here in front of the Dropbox office, I might recognize you.\n\n32:56.320 --> 33:01.320\n Even if I'm wearing a different shirt, yeah, but if I see you tomorrow in a coffee shop\n\n33:01.320 --> 33:06.640\n in Belmont, I might have no idea that it was you or on the beach or whatever.\n\n33:06.640 --> 33:10.160\n I make those kind of mistakes myself all the time.\n\n33:10.160 --> 33:16.320\n I see someone that I only know as like, oh, this person is a colleague of my wife's and\n\n33:16.320 --> 33:20.860\n then I see them at the movies and I didn't recognize them.\n\n33:20.860 --> 33:29.320\n But do you see those, you call it pattern matching, do you see that rules is unable\n\n33:29.320 --> 33:32.380\n to encode that?\n\n33:32.380 --> 33:36.320\n Everything you see, all the pieces of information you look around this room, I'm wearing a black\n\n33:36.320 --> 33:41.720\n shirt, I have a certain height, I'm a human, all these, there's probably tens of thousands\n\n33:41.720 --> 33:45.680\n of facts you pick up moment by moment about this scene.\n\n33:45.680 --> 33:50.000\n You take them for granted and you aggregate them together to understand the scene.\n\n33:50.000 --> 33:53.800\n You don't think all of that could be encoded to where at the end of the day, you can just\n\n33:53.800 --> 33:57.440\n put it all on the table and calculate?\n\n33:57.440 --> 33:58.840\n I don't know what that means.\n\n33:58.840 --> 34:08.680\n I mean, yes, in the sense that there is no actual magic there, but there are enough layers\n\n34:08.680 --> 34:17.640\n of abstraction from the facts as they enter my eyes and my ears to the understanding of\n\n34:17.640 --> 34:29.240\n the scene that I don't think that AI has really covered enough of that distance.\n\n34:29.240 --> 34:37.800\n It's like if you take a human body and you realize it's built out of atoms, well, that\n\n34:37.800 --> 34:41.960\n is a uselessly reductionist view, right?\n\n34:41.960 --> 34:46.380\n The body is built out of organs, the organs are built out of cells, the cells are built\n\n34:46.380 --> 34:53.240\n out of proteins, the proteins are built out of amino acids, the amino acids are built\n\n34:53.240 --> 34:58.040\n out of atoms and then you get to quantum mechanics.\n\n34:58.040 --> 34:59.920\n So that's a very pragmatic view.\n\n34:59.920 --> 35:03.720\n I mean, obviously as an engineer, I agree with that kind of view, but you also have\n\n35:03.720 --> 35:13.160\n to consider the Sam Harris view of, well, intelligence is just information processing.\n\n35:13.160 --> 35:17.320\n Like you said, you take in sensory information, you do some stuff with it and you come up\n\n35:17.320 --> 35:20.760\n with actions that are intelligent.\n\n35:20.760 --> 35:22.480\n That makes it sound so easy.\n\n35:22.480 --> 35:24.280\n I don't know who Sam Harris is.\n\n35:24.280 --> 35:26.400\n Oh, well, it's a philosopher.\n\n35:26.400 --> 35:29.680\n So like this is how philosophers often think, right?\n\n35:29.680 --> 35:33.760\n And essentially that's what Descartes was, is wait a minute, if there is, like you said,\n\n35:33.760 --> 35:39.320\n no magic, so he basically says it doesn't appear like there's any magic, but we know\n\n35:39.320 --> 35:44.280\n so little about it that it might as well be magic.\n\n35:44.280 --> 35:47.800\n So just because we know that we're made of atoms, just because we know we're made\n\n35:47.800 --> 35:53.280\n of organs, the fact that we know very little how to get from the atoms to organs in a way\n\n35:53.280 --> 36:00.400\n that's recreatable means that you shouldn't get too excited just yet about the fact that\n\n36:00.400 --> 36:02.240\n you figured out that we're made of atoms.\n\n36:02.240 --> 36:11.920\n Right, and the same about taking facts as our sensory organs take them in and turning\n\n36:11.920 --> 36:19.820\n that into reasons and actions, that sort of, there are a lot of abstractions that we haven't\n\n36:19.820 --> 36:23.960\n quite figured out how to deal with those.\n\n36:23.960 --> 36:37.440\n I mean, sometimes, I don't know if I can go on a tangent or not, so if I take a simple\n\n36:37.440 --> 36:45.640\n program that parses, say I have a compiler that parses a program, in a sense the input\n\n36:45.640 --> 36:55.640\n routine of that compiler, of that parser, is a sensing organ, and it builds up a mighty\n\n36:55.640 --> 37:01.960\n complicated internal representation of the program it just saw, it doesn't just have\n\n37:01.960 --> 37:08.200\n a linear sequence of bytes representing the text of the program anymore, it has an abstract\n\n37:08.200 --> 37:15.480\n syntax tree, and I don't know how many of your viewers or listeners are familiar with\n\n37:15.480 --> 37:18.680\n compiler technology, but there's\u2026\n\n37:18.680 --> 37:21.880\n Fewer and fewer these days, right?\n\n37:21.880 --> 37:24.920\n That's also true, probably.\n\n37:24.920 --> 37:30.360\n People want to take a shortcut, but there's sort of, this abstraction is a data structure\n\n37:30.360 --> 37:37.480\n that the compiler then uses to produce outputs that is relevant, like a translation of that\n\n37:37.480 --> 37:47.880\n program to machine code that can be executed by hardware, and then that data structure\n\n37:47.880 --> 37:50.600\n gets thrown away.\n\n37:50.600 --> 38:02.560\n When a fish or a fly sees, sort of gets visual impulses, I'm sure it also builds up some\n\n38:02.560 --> 38:10.000\n data structure, and for the fly that may be very minimal, a fly may have only a few, I\n\n38:10.000 --> 38:17.680\n mean, in the case of a fly's brain, I could imagine that there are few enough layers of\n\n38:17.680 --> 38:24.040\n abstraction that it's not much more than when it's darker here than it is here, well\n\n38:24.040 --> 38:29.880\n it can sense motion, because a fly sort of responds when you move your arm towards it,\n\n38:29.880 --> 38:39.240\n so clearly its visual processing is intelligent, well, not intelligent, but it has an abstraction\n\n38:39.240 --> 38:46.440\n for motion, and we still have similar things in, but much more complicated in our brains,\n\n38:46.440 --> 38:50.400\n I mean, otherwise you couldn't drive a car if you couldn't, if you didn't have an\n\n38:50.400 --> 38:53.480\n incredibly good abstraction for motion.\n\n38:53.480 --> 38:59.160\n Yeah, in some sense, the same abstraction for motion is probably one of the primary\n\n38:59.160 --> 39:05.080\n sources of our, of information for us, we just know what to do, I think we know what\n\n39:05.080 --> 39:08.280\n to do with that, we've built up other abstractions on top.\n\n39:08.280 --> 39:14.120\n We build much more complicated data structures based on that, and we build more persistent\n\n39:14.120 --> 39:20.320\n data structures, sort of after some processing, some information sort of gets stored in our\n\n39:20.320 --> 39:27.240\n memory pretty much permanently, and is available on recall, I mean, there are some things that\n\n39:27.240 --> 39:34.040\n you sort of, you're conscious that you're remembering it, like, you give me your phone\n\n39:34.040 --> 39:39.560\n number, I, well, at my age I have to write it down, but I could imagine, I could remember\n\n39:39.560 --> 39:46.240\n those seven numbers, or ten digits, and reproduce them in a while, if I sort of repeat them\n\n39:46.240 --> 39:53.320\n to myself a few times, so that's a fairly conscious form of memorization.\n\n39:53.320 --> 39:57.800\n On the other hand, how do I recognize your face, I have no idea.\n\n39:57.800 --> 40:04.080\n My brain has a whole bunch of specialized hardware that knows how to recognize faces,\n\n40:04.080 --> 40:10.200\n I don't know how much of that is sort of coded in our DNA, and how much of that is\n\n40:10.200 --> 40:17.960\n trained over and over between the ages of zero and three, but somehow our brains know\n\n40:17.960 --> 40:26.000\n how to do lots of things like that, that are useful in our interactions with other humans,\n\n40:26.000 --> 40:29.880\n without really being conscious of how it's done anymore.\n\n40:29.880 --> 40:36.200\n Right, so our actual day to day lives, we're operating at the very highest level of abstraction,\n\n40:36.200 --> 40:39.760\n we're just not even conscious of all the little details underlying it.\n\n40:39.760 --> 40:43.360\n There's compilers on top of, it's like turtles on top of turtles, or turtles all the way\n\n40:43.360 --> 40:48.200\n down, there's compilers all the way down, but that's essentially, you say that there's\n\n40:48.200 --> 40:54.920\n no magic, that's what I, what I was trying to get at, I think, is with Descartes started\n\n40:54.920 --> 40:59.600\n this whole train of saying that there's no magic, I mean, there's all this beforehand.\n\n40:59.600 --> 41:06.120\n Well didn't Descartes also have the notion though that the soul and the body were fundamentally\n\n41:06.120 --> 41:07.120\n separate?\n\n41:07.120 --> 41:11.800\n Separate, yeah, I think he had to write in God in there for political reasons, so I don't\n\n41:11.800 --> 41:17.880\n know actually, I'm not a historian, but there's notions in there that all of reasoning, all\n\n41:17.880 --> 41:20.120\n of human thought can be formalized.\n\n41:20.120 --> 41:28.480\n I think that continued in the 20th century with Russell and with Gadot's incompleteness\n\n41:28.480 --> 41:33.120\n theorem, this debate of what are the limits of the things that could be formalized, that's\n\n41:33.120 --> 41:37.960\n where the Turing machine came along, and this exciting idea, I mean, underlying a lot of\n\n41:37.960 --> 41:43.160\n computing that you can do quite a lot with a computer.\n\n41:43.160 --> 41:47.640\n You can encode a lot of the stuff we're talking about in terms of recognizing faces and so\n\n41:47.640 --> 41:53.960\n on, theoretically, in an algorithm that can then run on a computer.\n\n41:53.960 --> 42:05.040\n And in that context, I'd like to ask programming in a philosophical way, what does it mean\n\n42:05.040 --> 42:06.480\n to program a computer?\n\n42:06.480 --> 42:13.360\n So you said you write a Python program or compiled a C++ program that compiles to some\n\n42:13.360 --> 42:21.200\n byte code, it's forming layers, you're programming a layer of abstraction that's higher, how\n\n42:21.200 --> 42:24.920\n do you see programming in that context?\n\n42:24.920 --> 42:29.800\n Can it keep getting higher and higher levels of abstraction?\n\n42:29.800 --> 42:35.960\n I think at some point the higher levels of abstraction will not be called programming\n\n42:35.960 --> 42:44.720\n and they will not resemble what we call programming at the moment.\n\n42:44.720 --> 42:52.080\n There will not be source code, I mean, there will still be source code sort of at a lower\n\n42:52.080 --> 42:59.320\n level of the machine, just like there are still molecules and electrons and sort of\n\n42:59.320 --> 43:09.120\n proteins in our brains, but, and so there's still programming and system administration\n\n43:09.120 --> 43:15.960\n and who knows what, to keep the machine running, but what the machine does is a different level\n\n43:15.960 --> 43:23.060\n of abstraction in a sense, and as far as I understand the way that for the last decade\n\n43:23.060 --> 43:28.440\n or more people have made progress with things like facial recognition or the self driving\n\n43:28.440 --> 43:38.200\n cars is all by endless, endless amounts of training data where at least as a lay person,\n\n43:38.200 --> 43:47.420\n and I feel myself totally as a lay person in that field, it looks like the researchers\n\n43:47.420 --> 43:57.400\n who publish the results don't necessarily know exactly how their algorithms work, and\n\n43:57.400 --> 44:04.840\n I often get upset when I sort of read a sort of a fluff piece about Facebook in the newspaper\n\n44:04.840 --> 44:12.680\n or social networks and they say, well, algorithms, and that's like a totally different interpretation\n\n44:12.680 --> 44:19.240\n of the word algorithm, because for me, the way I was trained or what I learned when I\n\n44:19.240 --> 44:25.920\n was eight or ten years old, an algorithm is a set of rules that you completely understand\n\n44:25.920 --> 44:30.720\n that can be mathematically analyzed and you can prove things.\n\n44:30.720 --> 44:37.840\n You can like prove that Aristotelian sieve produces all prime numbers and only prime\n\n44:37.840 --> 44:38.840\n numbers.\n\n44:38.840 --> 44:39.840\n Yeah.\n\n44:39.840 --> 44:44.360\n So I don't know if you know who Andrej Karpathy is, I'm afraid not.\n\n44:44.360 --> 44:51.980\n So he's a head of AI at Tesla now, but he was at Stanford before and he has this cheeky\n\n44:51.980 --> 44:56.480\n way of calling this concept software 2.0.\n\n44:56.480 --> 45:00.120\n So let me disentangle that for a second.\n\n45:00.120 --> 45:06.080\n So kind of what you're referring to is the traditional, the algorithm, the concept of\n\n45:06.080 --> 45:09.560\n an algorithm, something that's there, it's clear, you can read it, you understand it,\n\n45:09.560 --> 45:14.800\n you can prove it's functioning as kind of software 1.0.\n\n45:14.800 --> 45:21.920\n And what software 2.0 is, is exactly what you described, which is you have neural networks,\n\n45:21.920 --> 45:26.600\n which is a type of machine learning that you feed a bunch of data and that neural network\n\n45:26.600 --> 45:30.200\n learns to do a function.\n\n45:30.200 --> 45:35.220\n All you specify is the inputs and the outputs you want and you can't look inside.\n\n45:35.220 --> 45:37.040\n You can't analyze it.\n\n45:37.040 --> 45:41.920\n All you can do is train this function to map the inputs to the outputs by giving a lot\n\n45:41.920 --> 45:42.920\n of data.\n\n45:42.920 --> 45:47.040\n And that's as programming becomes getting a lot of data.\n\n45:47.040 --> 45:48.920\n That's what programming is.\n\n45:48.920 --> 45:52.120\n Well, that would be programming 2.0.\n\n45:52.120 --> 45:53.800\n To programming 2.0.\n\n45:53.800 --> 45:55.600\n I wouldn't call that programming.\n\n45:55.600 --> 45:57.480\n It's just a different activity.\n\n45:57.480 --> 46:02.640\n Just like building organs out of cells is not called chemistry.\n\n46:02.640 --> 46:09.680\n Well, so let's just step back and think sort of more generally, of course.\n\n46:09.680 --> 46:18.080\n But you know, it's like as a parent teaching your kids, things can be called programming.\n\n46:18.080 --> 46:22.720\n In that same sense, that's how programming is being used.\n\n46:22.720 --> 46:27.080\n You're providing them data, examples, use cases.\n\n46:27.080 --> 46:36.680\n So imagine writing a function not by, not with for loops and clearly readable text,\n\n46:36.680 --> 46:42.760\n but more saying, well, here's a lot of examples of what this function should take.\n\n46:42.760 --> 46:47.860\n And here's a lot of examples of when it takes those functions, it should do this.\n\n46:47.860 --> 46:50.280\n And then figure out the rest.\n\n46:50.280 --> 46:52.640\n So that's the 2.0 concept.\n\n46:52.640 --> 46:58.560\n And so the question I have for you is like, it's a very fuzzy way.\n\n46:58.560 --> 47:01.680\n This is the reality of a lot of these pattern recognition systems and so on.\n\n47:01.680 --> 47:05.400\n It's a fuzzy way of quote unquote programming.\n\n47:05.400 --> 47:09.160\n What do you think about this kind of world?\n\n47:09.160 --> 47:13.640\n Should it be called something totally different than programming?\n\n47:13.640 --> 47:21.000\n If you're a software engineer, does that mean you're designing systems that are very, can\n\n47:21.000 --> 47:28.140\n be systematically tested, evaluated, they have a very specific specification and then this\n\n47:28.140 --> 47:33.520\n other fuzzy software 2.0 world, machine learning world, that's something else totally?\n\n47:33.520 --> 47:41.000\n Or is there some intermixing that's possible?\n\n47:41.000 --> 47:48.600\n Well the question is probably only being asked because we don't quite know what that software\n\n47:48.600 --> 47:51.400\n 2.0 actually is.\n\n47:51.400 --> 48:02.960\n And I think there is a truism that every task that AI has tackled in the past, at some point\n\n48:02.960 --> 48:09.160\n we realized how it was done and then it was no longer considered part of artificial intelligence\n\n48:09.160 --> 48:15.200\n because it was no longer necessary to use that term.\n\n48:15.200 --> 48:21.600\n It was just, oh now we know how to do this.\n\n48:21.600 --> 48:30.320\n And a new field of science or engineering has been developed and I don't know if sort\n\n48:30.320 --> 48:39.000\n of every form of learning or sort of controlling computer systems should always be called programming.\n\n48:39.000 --> 48:43.720\n So I don't know, maybe I'm focused too much on the terminology.\n\n48:43.720 --> 48:56.200\n But I expect that there just will be different concepts where people with sort of different\n\n48:56.200 --> 49:07.920\n education and a different model of what they're trying to do will develop those concepts.\n\n49:07.920 --> 49:17.240\n I guess if you could comment on another way to put this concept is, I think the kind of\n\n49:17.240 --> 49:23.480\n functions that neural networks provide is things as opposed to being able to upfront\n\n49:23.480 --> 49:28.720\n prove that this should work for all cases you throw at it.\n\n49:28.720 --> 49:32.320\n All you're able, it's the worst case analysis versus average case analysis.\n\n49:32.320 --> 49:39.800\n All you're able to say is it seems on everything we've tested to work 99.9% of the time, but\n\n49:39.800 --> 49:44.160\n we can't guarantee it and it fails in unexpected ways.\n\n49:44.160 --> 49:48.080\n We can't even give you examples of how it fails in unexpected ways, but it's like really\n\n49:48.080 --> 49:50.120\n good most of the time.\n\n49:50.120 --> 50:00.720\n Is there no room for that in current ways we think about programming?\n\n50:00.720 --> 50:11.080\n programming 1.0 is actually sort of getting to that point too, where the sort of the ideal\n\n50:11.080 --> 50:21.120\n of a bug free program has been abandoned long ago by most software developers.\n\n50:21.120 --> 50:30.120\n We only care about bugs that manifest themselves often enough to be annoying.\n\n50:30.120 --> 50:40.680\n And we're willing to take the occasional crash or outage or incorrect result for granted\n\n50:40.680 --> 50:47.600\n because we can't possibly, we don't have enough programmers to make all the code bug free\n\n50:47.600 --> 50:50.200\n and it would be an incredibly tedious business.\n\n50:50.200 --> 50:56.320\n And if you try to throw formal methods at it, it becomes even more tedious.\n\n50:56.320 --> 51:05.520\n So every once in a while the user clicks on a link and somehow they get an error and the\n\n51:05.520 --> 51:07.360\n average user doesn't panic.\n\n51:07.360 --> 51:14.840\n They just click again and see if it works better the second time, which often magically\n\n51:14.840 --> 51:21.600\n it does, or they go up and they try some other way of performing their tasks.\n\n51:21.600 --> 51:29.880\n So that's sort of an end to end recovery mechanism and inside systems there is all\n\n51:29.880 --> 51:39.120\n sorts of retries and timeouts and fallbacks and I imagine that that sort of biological\n\n51:39.120 --> 51:46.320\n systems are even more full of that because otherwise they wouldn't survive.\n\n51:46.320 --> 51:54.160\n Do you think programming should be taught and thought of as exactly what you just said?\n\n51:54.160 --> 52:01.560\n I come from this kind of, you're always denying that fact always.\n\n52:01.560 --> 52:12.680\n In sort of basic programming education, the sort of the programs you're having students\n\n52:12.680 --> 52:23.480\n write are so small and simple that if there is a bug you can always find it and fix it.\n\n52:23.480 --> 52:29.720\n Because the sort of programming as it's being taught in some, even elementary, middle schools,\n\n52:29.720 --> 52:36.680\n in high school, introduction to programming classes in college typically, it's programming\n\n52:36.680 --> 52:38.920\n in the small.\n\n52:38.920 --> 52:47.560\n Very few classes sort of actually teach software engineering, building large systems.\n\n52:47.560 --> 52:51.360\n Every summer here at Dropbox we have a large number of interns.\n\n52:51.360 --> 52:56.720\n Every tech company on the West Coast has the same thing.\n\n52:56.720 --> 53:02.520\n These interns are always amazed because this is the first time in their life that they\n\n53:02.520 --> 53:12.920\n see what goes on in a really large software development environment.\n\n53:12.920 --> 53:20.280\n Everything they've learned in college was almost always about a much smaller scale and\n\n53:20.280 --> 53:27.840\n somehow that difference in scale makes a qualitative difference in how you do things and how you\n\n53:27.840 --> 53:29.600\n think about it.\n\n53:29.600 --> 53:36.300\n If you then take a few steps back into decades, 70s and 80s, when you were first thinking\n\n53:36.300 --> 53:41.840\n about Python or just that world of programming languages, did you ever think that there would\n\n53:41.840 --> 53:46.720\n be systems as large as underlying Google, Facebook, and Dropbox?\n\n53:46.720 --> 53:51.440\n Did you, when you were thinking about Python?\n\n53:51.440 --> 53:57.520\n I was actually always caught by surprise by sort of this, yeah, pretty much every stage\n\n53:57.520 --> 53:59.680\n of computing.\n\n53:59.680 --> 54:07.280\n So maybe just because you've spoken in other interviews, but I think the evolution of programming\n\n54:07.280 --> 54:13.080\n languages are fascinating and it's especially because it leads from my perspective towards\n\n54:13.080 --> 54:15.640\n greater and greater degrees of intelligence.\n\n54:15.640 --> 54:21.880\n I learned the first programming language I played with in Russia was with the Turtle\n\n54:21.880 --> 54:22.880\n logo.\n\n54:22.880 --> 54:24.840\n Logo, yeah.\n\n54:24.840 --> 54:29.960\n And if you look, I just have a list of programming languages, all of which I've now played with\n\n54:29.960 --> 54:30.960\n a little bit.\n\n54:30.960 --> 54:36.640\n I mean, they're all beautiful in different ways from Fortran, Cobalt, Lisp, Algol 60,\n\n54:36.640 --> 54:46.160\n Basic, Logo again, C, as a few, the object oriented came along in the 60s, Simula, Pascal,\n\n54:46.160 --> 54:47.560\n Smalltalk.\n\n54:47.560 --> 54:48.560\n All of that leads.\n\n54:48.560 --> 54:49.560\n They're all the classics.\n\n54:49.560 --> 54:50.560\n The classics.\n\n54:50.560 --> 54:51.560\n Yeah.\n\n54:51.560 --> 54:52.560\n The classic hits, right?\n\n54:52.560 --> 54:58.280\n Steam, that's built on top of Lisp.\n\n54:58.280 --> 55:05.900\n On the database side, SQL, C++, and all of that leads up to Python, Pascal too, and that's\n\n55:05.900 --> 55:10.960\n before Python, MATLAB, these kind of different communities, different languages.\n\n55:10.960 --> 55:13.240\n So can you talk about that world?\n\n55:13.240 --> 55:18.680\n I know that sort of Python came out of ABC, which I actually never knew that language.\n\n55:18.680 --> 55:24.400\n I just, having researched this conversation, went back to ABC and it looks remarkably,\n\n55:24.400 --> 55:31.240\n it has a lot of annoying qualities, but underneath those, like all caps and so on, but underneath\n\n55:31.240 --> 55:35.720\n that, there's elements of Python that are quite, they're already there.\n\n55:35.720 --> 55:37.540\n That's where I got all the good stuff.\n\n55:37.540 --> 55:38.540\n All the good stuff.\n\n55:38.540 --> 55:41.580\n So, but in that world, you're swimming these programming languages, were you focused on\n\n55:41.580 --> 55:48.080\n just the good stuff in your specific circle, or did you have a sense of what is everyone\n\n55:48.080 --> 55:49.080\n chasing?\n\n55:49.080 --> 55:57.000\n You said that every programming language is built to scratch an itch.\n\n55:57.000 --> 55:59.920\n Were you aware of all the itches in the community?\n\n55:59.920 --> 56:05.080\n And if not, or if yes, I mean, what itch were you trying to scratch with Python?\n\n56:05.080 --> 56:12.040\n Well, I'm glad I wasn't aware of all the itches because I would probably not have been able\n\n56:12.040 --> 56:14.040\n to do anything.\n\n56:14.040 --> 56:19.760\n I mean, if you're trying to solve every problem at once, you'll solve nothing.\n\n56:19.760 --> 56:23.880\n Well, yeah, it's too overwhelming.\n\n56:23.880 --> 56:28.360\n And so I had a very, very focused problem.\n\n56:28.360 --> 56:41.880\n I wanted a programming language that sat somewhere in between shell scripting and C. And now,\n\n56:41.880 --> 56:48.720\n arguably, there is like, one is higher level, one is lower level.\n\n56:48.720 --> 56:56.760\n And Python is sort of a language of an intermediate level, although it's still pretty much at\n\n56:56.760 --> 57:00.560\n the high level end.\n\n57:00.560 --> 57:11.200\n I was thinking about much more about, I want a tool that I can use to be more productive\n\n57:11.200 --> 57:16.640\n as a programmer in a very specific environment.\n\n57:16.640 --> 57:22.280\n And I also had given myself a time budget for the development of the tool.\n\n57:22.280 --> 57:29.340\n And that was sort of about three months for both the design, like thinking through what\n\n57:29.340 --> 57:38.900\n are all the features of the language syntactically and semantically, and how do I implement the\n\n57:38.900 --> 57:43.680\n whole pipeline from parsing the source code to executing it.\n\n57:43.680 --> 57:51.440\n So I think both with the timeline and the goals, it seems like productivity was at the\n\n57:51.440 --> 57:54.040\n core of it as a goal.\n\n57:54.040 --> 58:01.280\n So like, for me in the 90s, and the first decade of the 21st century, I was always doing\n\n58:01.280 --> 58:07.620\n machine learning, AI programming for my research was always in C++.\n\n58:07.620 --> 58:14.240\n And then the other people who are a little more mechanical engineering, electrical engineering,\n\n58:14.240 --> 58:15.240\n are MATLABby.\n\n58:15.240 --> 58:18.520\n They're a little bit more MATLAB focused.\n\n58:18.520 --> 58:21.200\n Those are the world, and maybe a little bit Java too.\n\n58:21.200 --> 58:29.160\n But people who are more interested in emphasizing the object oriented nature of things.\n\n58:29.160 --> 58:34.920\n So within the last 10 years or so, especially with the oncoming of neural networks and these\n\n58:34.920 --> 58:41.360\n packages that are built on Python to interface with neural networks, I switched to Python\n\n58:41.360 --> 58:47.120\n and it's just, I've noticed a significant boost that I can't exactly, because I don't\n\n58:47.120 --> 58:52.840\n think about it, but I can't exactly put into words why I'm just much, much more productive.\n\n58:52.840 --> 58:56.400\n Just being able to get the job done much, much faster.\n\n58:56.400 --> 59:01.880\n So how do you think, whatever that qualitative difference is, I don't know if it's quantitative,\n\n59:01.880 --> 59:07.280\n it could be just a feeling, I don't know if I'm actually more productive, but how\n\n59:07.280 --> 59:08.280\n do you think about...\n\n59:08.280 --> 59:09.280\n You probably are.\n\n59:09.280 --> 59:10.280\n Yeah.\n\n59:10.280 --> 59:11.880\n Well, that's right.\n\n59:11.880 --> 59:15.400\n I think there's elements, let me just speak to one aspect that I think that was affecting\n\n59:15.400 --> 59:26.160\n my productivity is C++ was, I really enjoyed creating performant code and creating a beautiful\n\n59:26.160 --> 59:31.000\n structure where everything that, you know, this kind of going into this, especially with\n\n59:31.000 --> 59:37.080\n the newer and newer standards of templated programming of just really creating this beautiful\n\n59:37.080 --> 59:42.000\n formal structure that I found myself spending most of my time doing that as opposed to getting\n\n59:42.000 --> 59:47.520\n it, parsing a file and extracting a few keywords or whatever the task was trying to do.\n\n59:47.520 --> 59:49.980\n So what is it about Python?\n\n59:49.980 --> 59:54.520\n How do you think of productivity in general as you were designing it now, sort of through\n\n59:54.520 --> 1:00:00.120\n the decades, last three decades, what do you think it means to be a productive programmer?\n\n1:00:00.120 --> 1:00:03.560\n And how did you try to design it into the language?\n\n1:00:03.560 --> 1:00:10.400\n There are different tasks and as a programmer, it's useful to have different tools available\n\n1:00:10.400 --> 1:00:13.940\n that sort of are suitable for different tasks.\n\n1:00:13.940 --> 1:00:25.600\n So I still write C code, I still write shell code, but I write most of my things in Python.\n\n1:00:25.600 --> 1:00:33.000\n Why do I still use those other languages, because sometimes the task just demands it.\n\n1:00:33.000 --> 1:00:39.000\n And well, I would say most of the time the task actually demands a certain language because\n\n1:00:39.000 --> 1:00:45.600\n the task is not write a program that solves problem X from scratch, but it's more like\n\n1:00:45.600 --> 1:00:56.680\n fix a bug in existing program X or add a small feature to an existing large program.\n\n1:00:56.680 --> 1:01:10.160\n But even if you're not constrained in your choice of language by context like that, there\n\n1:01:10.160 --> 1:01:21.360\n is still the fact that if you write it in a certain language, then you have this balance\n\n1:01:21.360 --> 1:01:31.840\n between how long does it take you to write the code and how long does the code run?\n\n1:01:31.840 --> 1:01:42.760\n And when you're in the phase of exploring solutions, you often spend much more time\n\n1:01:42.760 --> 1:01:50.720\n writing the code than running it because every time you've run it, you see that the output\n\n1:01:50.720 --> 1:01:58.480\n is not quite what you wanted and you spend some more time coding.\n\n1:01:58.480 --> 1:02:06.760\n And a language like Python just makes that iteration much faster because there are fewer\n\n1:02:06.760 --> 1:02:19.480\n details that you have to get right before your program compiles and runs.\n\n1:02:19.480 --> 1:02:26.400\n There are libraries that do all sorts of stuff for you, so you can sort of very quickly take\n\n1:02:26.400 --> 1:02:36.320\n a bunch of existing components, put them together, and get your prototype application running.\n\n1:02:36.320 --> 1:02:42.860\n Just like when I was building electronics, I was using a breadboard most of the time,\n\n1:02:42.860 --> 1:02:51.320\n so I had this sprawl out circuit that if you shook it, it would stop working because it\n\n1:02:51.320 --> 1:02:58.800\n was not put together very well, but it functioned and all I wanted was to see that it worked\n\n1:02:58.800 --> 1:03:05.000\n and then move on to the next schematic or design or add something to it.\n\n1:03:05.000 --> 1:03:10.500\n Once you've sort of figured out, oh, this is the perfect design for my radio or light\n\n1:03:10.500 --> 1:03:15.800\n sensor or whatever, then you can say, okay, how do we design a PCB for this?\n\n1:03:15.800 --> 1:03:19.920\n How do we solder the components in a small space?\n\n1:03:19.920 --> 1:03:32.840\n How do we make it so that it is robust against, say, voltage fluctuations or mechanical disruption?\n\n1:03:32.840 --> 1:03:37.320\n I know nothing about that when it comes to designing electronics, but I know a lot about\n\n1:03:37.320 --> 1:03:40.400\n that when it comes to writing code.\n\n1:03:40.400 --> 1:03:46.080\n So the initial steps are efficient, fast, and there's not much stuff that gets in the\n\n1:03:46.080 --> 1:03:56.680\n way, but you're kind of describing, like Darwin described the evolution of species, right?\n\n1:03:56.680 --> 1:04:00.520\n You're observing of what is true about Python.\n\n1:04:00.520 --> 1:04:07.800\n Now if you take a step back, if the act of creating languages is art and you had three\n\n1:04:07.800 --> 1:04:15.640\n months to do it, initial steps, so you just specified a bunch of goals, sort of things\n\n1:04:15.640 --> 1:04:19.400\n that you observe about Python, perhaps you had those goals, but how do you create the\n\n1:04:19.400 --> 1:04:25.600\n rules, the syntactic structure, the features that result in those?\n\n1:04:25.600 --> 1:04:29.880\n So I have in the beginning and I have follow up questions about through the evolution of\n\n1:04:29.880 --> 1:04:35.440\n Python too, but in the very beginning when you were sitting there creating the lexical\n\n1:04:35.440 --> 1:04:37.440\n analyzer or whatever.\n\n1:04:37.440 --> 1:04:47.240\n Python was still a big part of it because I sort of, I said to myself, I don't want\n\n1:04:47.240 --> 1:04:53.640\n to have to design everything from scratch, I'm going to borrow features from other languages\n\n1:04:53.640 --> 1:04:54.640\n that I like.\n\n1:04:54.640 --> 1:04:55.640\n Oh, interesting.\n\n1:04:55.640 --> 1:04:58.360\n So you basically, exactly, you first observe what you like.\n\n1:04:58.360 --> 1:05:05.240\n Yeah, and so that's why if you're 17 years old and you want to sort of create a programming\n\n1:05:05.240 --> 1:05:11.600\n language, you're not going to be very successful at it because you have no experience with\n\n1:05:11.600 --> 1:05:24.300\n other languages, whereas I was in my, let's say mid 30s, I had written parsers before,\n\n1:05:24.300 --> 1:05:30.880\n so I had worked on the implementation of ABC, I had spent years debating the design of ABC\n\n1:05:30.880 --> 1:05:37.520\n with its authors, with its designers, I had nothing to do with the design, it was designed\n\n1:05:37.520 --> 1:05:42.080\n fully as it ended up being implemented when I joined the team.\n\n1:05:42.080 --> 1:05:51.440\n But so you borrow ideas and concepts and very concrete sort of local rules from different\n\n1:05:51.440 --> 1:05:58.920\n languages like the indentation and certain other syntactic features from ABC, but I chose\n\n1:05:58.920 --> 1:06:07.960\n to borrow string literals and how numbers work from C and various other things.\n\n1:06:07.960 --> 1:06:13.800\n So in then, if you take that further, so yet you've had this funny sounding, but I think\n\n1:06:13.800 --> 1:06:21.000\n surprisingly accurate and at least practical title of benevolent dictator for life for\n\n1:06:21.000 --> 1:06:25.240\n quite, you know, for the last three decades or whatever, or no, not the actual title,\n\n1:06:25.240 --> 1:06:27.940\n but functionally speaking.\n\n1:06:27.940 --> 1:06:34.280\n So you had to make decisions, design decisions.\n\n1:06:34.280 --> 1:06:41.960\n Can you maybe, let's take Python 2, so releasing Python 3 as an example.\n\n1:06:41.960 --> 1:06:47.240\n It's not backward compatible to Python 2 in ways that a lot of people know.\n\n1:06:47.240 --> 1:06:50.640\n So what was that deliberation, discussion, decision like?\n\n1:06:50.640 --> 1:06:51.640\n Yeah.\n\n1:06:51.640 --> 1:06:54.520\n What was the psychology of that experience?\n\n1:06:54.520 --> 1:06:58.520\n Do you regret any aspects of how that experience undergone that?\n\n1:06:58.520 --> 1:07:03.040\n Well, yeah, so it was a group process really.\n\n1:07:03.040 --> 1:07:11.880\n At that point, even though I was BDFL in name and certainly everybody sort of respected\n\n1:07:11.880 --> 1:07:22.160\n my position as the creator and the current sort of owner of the language design, I was\n\n1:07:22.160 --> 1:07:26.560\n looking at everyone else for feedback.\n\n1:07:26.560 --> 1:07:35.280\n Sort of Python 3.0 in some sense was sparked by other people in the community pointing\n\n1:07:35.280 --> 1:07:46.360\n out, oh, well, there are a few issues that sort of bite users over and over.\n\n1:07:46.360 --> 1:07:48.920\n Can we do something about that?\n\n1:07:48.920 --> 1:07:56.360\n And for Python 3, we took a number of those Python words as they were called at the time\n\n1:07:56.360 --> 1:08:04.800\n and we said, can we try to sort of make small changes to the language that address those\n\n1:08:04.800 --> 1:08:06.560\n words?\n\n1:08:06.560 --> 1:08:15.360\n And we had sort of in the past, we had always taken backwards compatibility very seriously.\n\n1:08:15.360 --> 1:08:20.420\n And so many Python words in earlier versions had already been resolved because they could\n\n1:08:20.420 --> 1:08:29.740\n be resolved while maintaining backwards compatibility or sort of using a very gradual path of evolution\n\n1:08:29.740 --> 1:08:31.960\n of the language in a certain area.\n\n1:08:31.960 --> 1:08:39.760\n And so we were stuck with a number of words that were widely recognized as problems, not\n\n1:08:39.760 --> 1:08:47.680\n like roadblocks, but nevertheless sort of things that some people trip over and you know that\n\n1:08:47.680 --> 1:08:52.080\n that's always the same thing that people trip over when they trip.\n\n1:08:52.080 --> 1:08:58.480\n And we could not think of a backwards compatible way of resolving those issues.\n\n1:08:58.480 --> 1:09:01.920\n But it's still an option to not resolve the issues, right?\n\n1:09:01.920 --> 1:09:07.920\n And so yes, for a long time, we had sort of resigned ourselves to, well, okay, the language\n\n1:09:07.920 --> 1:09:13.400\n is not going to be perfect in this way and that way and that way.\n\n1:09:13.400 --> 1:09:19.440\n And we sort of, certain of these, I mean, there are still plenty of things where you\n\n1:09:19.440 --> 1:09:32.680\n can say, well, that particular detail is better in Java or in R or in Visual Basic or whatever.\n\n1:09:32.680 --> 1:09:37.960\n And we're okay with that because, well, we can't easily change it.\n\n1:09:37.960 --> 1:09:38.960\n It's not too bad.\n\n1:09:38.960 --> 1:09:47.180\n We can do a little bit with user education or we can have a static analyzer or warnings\n\n1:09:47.180 --> 1:09:49.440\n in the parse or something.\n\n1:09:49.440 --> 1:09:54.880\n But there were things where we thought, well, these are really problems that are not going\n\n1:09:54.880 --> 1:09:55.880\n away.\n\n1:09:55.880 --> 1:10:00.840\n They are getting worse in the future.\n\n1:10:00.840 --> 1:10:03.040\n We should do something about that.\n\n1:10:03.040 --> 1:10:05.640\n But ultimately there is a decision to be made, right?\n\n1:10:05.640 --> 1:10:13.320\n So was that the toughest decision in the history of Python you had to make as the benevolent\n\n1:10:13.320 --> 1:10:15.180\n dictator for life?\n\n1:10:15.180 --> 1:10:20.160\n Or if not, what are there, maybe even on the smaller scale, what was the decision where\n\n1:10:20.160 --> 1:10:22.040\n you were really torn up about?\n\n1:10:22.040 --> 1:10:25.800\n Well, the toughest decision was probably to resign.\n\n1:10:25.800 --> 1:10:28.120\n All right, let's go there.\n\n1:10:28.120 --> 1:10:29.360\n Hold on a second then.\n\n1:10:29.360 --> 1:10:33.200\n Let me just, because in the interest of time too, because I have a few cool questions for\n\n1:10:33.200 --> 1:10:38.160\n you and let's touch a really important one because it was quite dramatic and beautiful\n\n1:10:38.160 --> 1:10:40.400\n in certain kinds of ways.\n\n1:10:40.400 --> 1:10:47.320\n In July this year, three months ago, you wrote, now that PEP 572 is done, I don't ever want\n\n1:10:47.320 --> 1:10:52.680\n to have to fight so hard for a PEP and find that so many people despise my decisions.\n\n1:10:52.680 --> 1:10:56.240\n I would like to remove myself entirely from the decision process.\n\n1:10:56.240 --> 1:11:01.520\n I'll still be there for a while as an ordinary core developer and I'll still be available\n\n1:11:01.520 --> 1:11:05.440\n to mentor people, possibly more available.\n\n1:11:05.440 --> 1:11:11.000\n But I'm basically giving myself a permanent vacation from being BDFL, benevolent dictator\n\n1:11:11.000 --> 1:11:12.000\n for life.\n\n1:11:12.000 --> 1:11:14.240\n And you all will be on your own.\n\n1:11:14.240 --> 1:11:19.720\n First of all, it's almost Shakespearean.\n\n1:11:19.720 --> 1:11:22.300\n I'm not going to appoint a successor.\n\n1:11:22.300 --> 1:11:24.640\n So what are you all going to do?\n\n1:11:24.640 --> 1:11:29.240\n Create a democracy, anarchy, a dictatorship, a federation?\n\n1:11:29.240 --> 1:11:34.560\n So that was a very dramatic and beautiful set of statements.\n\n1:11:34.560 --> 1:11:40.080\n It's almost, it's open ended nature called the community to create a future for Python.\n\n1:11:40.080 --> 1:11:43.280\n It's just kind of a beautiful aspect to it.\n\n1:11:43.280 --> 1:11:48.320\n So what, and dramatic, you know, what was making that decision like?\n\n1:11:48.320 --> 1:11:54.560\n What was on your heart, on your mind, stepping back now a few months later?\n\n1:11:54.560 --> 1:12:02.940\n I'm glad you liked the writing because it was actually written pretty quickly.\n\n1:12:02.940 --> 1:12:14.240\n It was literally something like after months and months of going around in circles, I had\n\n1:12:14.240 --> 1:12:26.240\n finally approved PEP572, which I had a big hand in its design, although I didn't initiate\n\n1:12:26.240 --> 1:12:27.760\n it originally.\n\n1:12:27.760 --> 1:12:36.320\n I sort of gave it a bunch of nudges in a direction that would be better for the language.\n\n1:12:36.320 --> 1:12:40.320\n So sorry, just to ask, is async IO, that's the one or no?\n\n1:12:40.320 --> 1:12:49.320\n PEP572 was actually a small feature, which is assignment expressions.\n\n1:12:49.320 --> 1:12:58.200\n That had been, there was just a lot of debate where a lot of people claimed that they knew\n\n1:12:58.200 --> 1:13:04.800\n what was Pythonic and what was not Pythonic, and they knew that this was going to destroy\n\n1:13:04.800 --> 1:13:06.080\n the language.\n\n1:13:06.080 --> 1:13:11.800\n This was like a violation of Python's most fundamental design philosophy, and I thought\n\n1:13:11.800 --> 1:13:17.200\n that was all bullshit because I was in favor of it, and I would think I know something\n\n1:13:17.200 --> 1:13:19.120\n about Python's design philosophy.\n\n1:13:19.120 --> 1:13:26.340\n So I was really tired and also stressed of that thing, and literally after sort of announcing\n\n1:13:26.340 --> 1:13:34.560\n I was going to accept it, a certain Wednesday evening I had finally sent the email, it's\n\n1:13:34.560 --> 1:13:35.560\n accepted.\n\n1:13:35.560 --> 1:13:38.920\n I can just go implement it.\n\n1:13:38.920 --> 1:13:44.120\n So I went to bed feeling really relieved, that's behind me.\n\n1:13:44.120 --> 1:13:54.320\n And I wake up Thursday morning, 7 a.m., and I think, well, that was the last one that's\n\n1:13:54.320 --> 1:14:03.880\n going to be such a terrible debate, and that's the last time that I let myself be so stressed\n\n1:14:03.880 --> 1:14:06.520\n out about a pep decision.\n\n1:14:06.520 --> 1:14:07.920\n I should just resign.\n\n1:14:07.920 --> 1:14:15.520\n I've been sort of thinking about retirement for half a decade, I've been joking and sort\n\n1:14:15.520 --> 1:14:22.460\n of mentioning retirement, sort of telling the community at some point in the future\n\n1:14:22.460 --> 1:14:29.400\n I'm going to retire, don't take that FL part of my title too literally.\n\n1:14:29.400 --> 1:14:32.080\n And I thought, okay, this is it.\n\n1:14:32.080 --> 1:14:39.200\n I'm done, I had the day off, I wanted to have a good time with my wife, we were going to\n\n1:14:39.200 --> 1:14:48.480\n a little beach town nearby, and in I think maybe 15, 20 minutes I wrote that thing that\n\n1:14:48.480 --> 1:14:51.320\n you just called Shakespearean.\n\n1:14:51.320 --> 1:15:01.560\n The funny thing is I didn't even realize what a monumental decision it was, because\n\n1:15:01.560 --> 1:15:09.200\n five minutes later I read that link to my message back on Twitter, where people were\n\n1:15:09.200 --> 1:15:15.280\n already discussing on Twitter, Guido resigned as the BDFL.\n\n1:15:15.280 --> 1:15:22.440\n And I had posted it on an internal forum that I thought was only read by core developers,\n\n1:15:22.440 --> 1:15:28.520\n so I thought I would at least have one day before the news would sort of get out.\n\n1:15:28.520 --> 1:15:36.200\n The on your own aspects had also an element of quite, it was quite a powerful element\n\n1:15:36.200 --> 1:15:43.080\n of the uncertainty that lies ahead, but can you also just briefly talk about, for example\n\n1:15:43.080 --> 1:15:49.920\n I play guitar as a hobby for fun, and whenever I play people are super positive, super friendly,\n\n1:15:49.920 --> 1:15:52.680\n they're like, this is awesome, this is great.\n\n1:15:52.680 --> 1:15:57.520\n But sometimes I enter as an outside observer, I enter the programming community and there\n\n1:15:57.520 --> 1:16:05.560\n seems to sometimes be camps on whatever the topic, and the two camps, the two or plus\n\n1:16:05.560 --> 1:16:11.700\n camps, are often pretty harsh at criticizing the opposing camps.\n\n1:16:11.700 --> 1:16:14.880\n As an onlooker, I may be totally wrong on this, but what do you think of this?\n\n1:16:14.880 --> 1:16:19.760\n Yeah, holy wars are sort of a favorite activity in the programming community.\n\n1:16:19.760 --> 1:16:22.120\n And what is the psychology behind that?\n\n1:16:22.120 --> 1:16:25.120\n Is that okay for a healthy community to have?\n\n1:16:25.120 --> 1:16:29.760\n Is that a productive force ultimately for the evolution of a language?\n\n1:16:29.760 --> 1:16:39.080\n Well, if everybody is patting each other on the back and never telling the truth, it would\n\n1:16:39.080 --> 1:16:40.840\n not be a good thing.\n\n1:16:40.840 --> 1:16:52.760\n I think there is a middle ground where sort of being nasty to each other is not okay,\n\n1:16:52.760 --> 1:17:01.760\n but there is a middle ground where there is healthy ongoing criticism and feedback that\n\n1:17:01.760 --> 1:17:04.780\n is very productive.\n\n1:17:04.780 --> 1:17:07.760\n And you mean at every level you see that.\n\n1:17:07.760 --> 1:17:17.760\n I mean, someone proposes to fix a very small issue in a code base, chances are that some\n\n1:17:17.760 --> 1:17:27.080\n reviewer will sort of respond by saying, well, actually, you can do it better the other way.\n\n1:17:27.080 --> 1:17:34.360\n When it comes to deciding on the future of the Python core developer community, we now\n\n1:17:34.360 --> 1:17:41.160\n have, I think, five or six competing proposals for a constitution.\n\n1:17:41.160 --> 1:17:48.040\n So that future, do you have a fear of that future, do you have a hope for that future?\n\n1:17:48.040 --> 1:17:51.280\n I'm very confident about that future.\n\n1:17:51.280 --> 1:17:58.920\n By and large, I think that the debate has been very healthy and productive.\n\n1:17:58.920 --> 1:18:07.680\n And I actually, when I wrote that resignation email, I knew that Python was in a very good\n\n1:18:07.680 --> 1:18:16.840\n spot and that the Python core developer community, the group of 50 or 100 people who sort of\n\n1:18:16.840 --> 1:18:24.720\n write or review most of the code that goes into Python, those people get along very well\n\n1:18:24.720 --> 1:18:27.680\n most of the time.\n\n1:18:27.680 --> 1:18:40.120\n A large number of different areas of expertise are represented, different levels of experience\n\n1:18:40.120 --> 1:18:45.440\n in the Python core dev community, different levels of experience completely outside it\n\n1:18:45.440 --> 1:18:53.040\n in software development in general, large systems, small systems, embedded systems.\n\n1:18:53.040 --> 1:19:03.880\n So I felt okay resigning because I knew that the community can really take care of itself.\n\n1:19:03.880 --> 1:19:12.360\n And out of a grab bag of future feature developments, let me ask if you can comment, maybe on all\n\n1:19:12.360 --> 1:19:19.120\n very quickly, concurrent programming, parallel computing, async IO.\n\n1:19:19.120 --> 1:19:24.880\n These are things that people have expressed hope, complained about, whatever, have discussed\n\n1:19:24.880 --> 1:19:25.880\n on Reddit.\n\n1:19:25.880 --> 1:19:32.200\n Async IO, so the parallelization in general, packaging, I was totally clueless on this.\n\n1:19:32.200 --> 1:19:38.600\n I just used pip to install stuff, but apparently there's pipenv, poetry, there's these dependency\n\n1:19:38.600 --> 1:19:41.300\n packaging systems that manage dependencies and so on.\n\n1:19:41.300 --> 1:19:45.520\n They're emerging and there's a lot of confusion about what's the right thing to use.\n\n1:19:45.520 --> 1:19:56.360\n Then also functional programming, are we going to get more functional programming or not,\n\n1:19:56.360 --> 1:19:59.040\n this kind of idea.\n\n1:19:59.040 --> 1:20:08.280\n And of course the GIL connected to the parallelization, I suppose, the global interpreter lock problem.\n\n1:20:08.280 --> 1:20:12.800\n Can you just comment on whichever you want to comment on?\n\n1:20:12.800 --> 1:20:25.440\n Well, let's take the GIL and parallelization and async IO as one topic.\n\n1:20:25.440 --> 1:20:35.820\n I'm not that hopeful that Python will develop into a sort of high concurrency, high parallelism\n\n1:20:35.820 --> 1:20:37.960\n language.\n\n1:20:37.960 --> 1:20:44.800\n That's sort of the way the language is designed, the way most users use the language, the way\n\n1:20:44.800 --> 1:20:50.280\n the language is implemented, all make that a pretty unlikely future.\n\n1:20:50.280 --> 1:20:56.040\n So you think it might not even need to, really the way people use it, it might not be something\n\n1:20:56.040 --> 1:20:58.160\n that should be of great concern.\n\n1:20:58.160 --> 1:21:05.620\n I think async IO is a special case because it sort of allows overlapping IO and only\n\n1:21:05.620 --> 1:21:18.160\n IO and that is a sort of best practice of supporting very high throughput IO, many connections\n\n1:21:18.160 --> 1:21:21.680\n per second.\n\n1:21:21.680 --> 1:21:22.780\n I'm not worried about that.\n\n1:21:22.780 --> 1:21:25.280\n I think async IO will evolve.\n\n1:21:25.280 --> 1:21:27.440\n There are a couple of competing packages.\n\n1:21:27.440 --> 1:21:36.800\n We have some very smart people who are sort of pushing us to make async IO better.\n\n1:21:36.800 --> 1:21:43.800\n Parallel computing, I think that Python is not the language for that.\n\n1:21:43.800 --> 1:21:53.560\n There are ways to work around it, but you can't expect to write an algorithm in Python\n\n1:21:53.560 --> 1:21:57.440\n and have a compiler automatically parallelize that.\n\n1:21:57.440 --> 1:22:03.520\n What you can do is use a package like NumPy and there are a bunch of other very powerful\n\n1:22:03.520 --> 1:22:12.480\n packages that sort of use all the CPUs available because you tell the package, here's the data,\n\n1:22:12.480 --> 1:22:19.040\n here's the abstract operation to apply over it, go at it, and then we're back in the C++\n\n1:22:19.040 --> 1:22:20.040\n world.\n\n1:22:20.040 --> 1:22:24.600\n Those packages are themselves implemented usually in C++.\n\n1:22:24.600 --> 1:22:28.000\n That's where TensorFlow and all these packages come in, where they parallelize across GPUs,\n\n1:22:28.000 --> 1:22:30.480\n for example, they take care of that for you.\n\n1:22:30.480 --> 1:22:36.600\n In terms of packaging, can you comment on the future of packaging in Python?\n\n1:22:36.600 --> 1:22:42.640\n Packaging has always been my least favorite topic.\n\n1:22:42.640 --> 1:22:55.600\n It's a really tough problem because the OS and the platform want to own packaging, but\n\n1:22:55.600 --> 1:23:01.000\n their packaging solution is not specific to a language.\n\n1:23:01.000 --> 1:23:07.480\n If you take Linux, there are two competing packaging solutions for Linux or for Unix\n\n1:23:07.480 --> 1:23:15.000\n in general, but they all work across all languages.\n\n1:23:15.000 --> 1:23:24.760\n Several languages like Node, JavaScript, Ruby, and Python all have their own packaging solutions\n\n1:23:24.760 --> 1:23:29.480\n that only work within the ecosystem of that language.\n\n1:23:29.480 --> 1:23:31.920\n What should you use?\n\n1:23:31.920 --> 1:23:34.560\n That is a tough problem.\n\n1:23:34.560 --> 1:23:43.520\n My own approach is I use the system packaging system to install Python, and I use the Python\n\n1:23:43.520 --> 1:23:49.280\n packaging system then to install third party Python packages.\n\n1:23:49.280 --> 1:23:51.480\n That's what most people do.\n\n1:23:51.480 --> 1:23:56.400\n Ten years ago, Python packaging was really a terrible situation.\n\n1:23:56.400 --> 1:24:05.360\n Nowadays, pip is the future, there is a separate ecosystem for numerical and scientific Python\n\n1:24:05.360 --> 1:24:08.200\n based on Anaconda.\n\n1:24:08.200 --> 1:24:09.760\n Those two can live together.\n\n1:24:09.760 --> 1:24:13.600\n I don't think there is a need for more than that.\n\n1:24:13.600 --> 1:24:14.600\n That's packaging.\n\n1:24:14.600 --> 1:24:18.720\n Well, at least for me, that's where I've been extremely happy.\n\n1:24:18.720 --> 1:24:22.320\n I didn't even know this was an issue until it was brought up.\n\n1:24:22.320 --> 1:24:27.600\n In the interest of time, let me sort of skip through a million other questions I have.\n\n1:24:27.600 --> 1:24:32.880\n So I watched the five and a half hour oral history that you've done with the Computer\n\n1:24:32.880 --> 1:24:37.600\n History Museum, and the nice thing about it, it gave this, because of the linear progression\n\n1:24:37.600 --> 1:24:44.480\n of the interview, it gave this feeling of a life, you know, a life well lived with interesting\n\n1:24:44.480 --> 1:24:52.160\n things in it, sort of a pretty, I would say a good spend of this little existence we have\n\n1:24:52.160 --> 1:24:53.160\n on Earth.\n\n1:24:53.160 --> 1:24:59.840\n So, outside of your family, looking back, what about this journey are you really proud\n\n1:24:59.840 --> 1:25:00.840\n of?\n\n1:25:00.840 --> 1:25:07.040\n Are there moments that stand out, accomplishments, ideas?\n\n1:25:07.040 --> 1:25:14.040\n Is it the creation of Python itself that stands out as a thing that you look back and say,\n\n1:25:14.040 --> 1:25:16.480\n damn, I did pretty good there?\n\n1:25:16.480 --> 1:25:25.520\n Well, I would say that Python is definitely the best thing I've ever done, and I wouldn't\n\n1:25:25.520 --> 1:25:36.560\n sort of say just the creation of Python, but the way I sort of raised Python, like a baby.\n\n1:25:36.560 --> 1:25:42.480\n I didn't just conceive a child, but I raised a child, and now I'm setting the child free\n\n1:25:42.480 --> 1:25:50.200\n in the world, and I've set up the child to sort of be able to take care of himself, and\n\n1:25:50.200 --> 1:25:52.640\n I'm very proud of that.\n\n1:25:52.640 --> 1:25:56.740\n And as the announcer of Monty Python's Flying Circus used to say, and now for something\n\n1:25:56.740 --> 1:26:02.280\n completely different, do you have a favorite Monty Python moment, or a moment in Hitchhiker's\n\n1:26:02.280 --> 1:26:07.720\n Guide, or any other literature show or movie that cracks you up when you think about it?\n\n1:26:07.720 --> 1:26:11.320\n You can always play me the dead parrot sketch.\n\n1:26:11.320 --> 1:26:13.680\n Oh, that's brilliant.\n\n1:26:13.680 --> 1:26:14.680\n That's my favorite as well.\n\n1:26:14.680 --> 1:26:15.680\n It's pushing up the daisies.\n\n1:26:15.680 --> 1:26:20.680\n Okay, Greta, thank you so much for talking with me today.\n\n1:26:20.680 --> 1:26:44.080\n Lex, this has been a great conversation.\n\n"
}